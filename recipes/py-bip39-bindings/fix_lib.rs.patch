--- src/lib.rs	2023-10-09 18:30:23.449536260 -0500
+++ src/lib.rs.new	2023-10-10 09:29:07.523461353 -0500
@@ -24,7 +24,7 @@
 use pyo3::prelude::*;
 use pyo3::{wrap_pyfunction};
 
-use bip39::{Mnemonic, Language, MnemonicType, Seed};
+use ::bip39::{Mnemonic, Language, MnemonicType, Seed};
 use hmac::Hmac;
 use pbkdf2::pbkdf2;
 use sha2::Sha512;
@@ -41,18 +41,18 @@
 ///
 /// Returns the 32-bytes mini-secret via entropy
 #[pyfunction]
-#[text_signature = "(phrase, password, language_code, /)"]
+#[pyo3(text_signature = "(phrase, password, language_code, /)")]
 pub fn bip39_to_mini_secret(phrase: &str, password: &str, language_code: Option<&str>) -> PyResult<Vec<u8>> {
 	let salt = format!("mnemonic{}", password);
 
 	let language = match Language::from_language_code(language_code.unwrap_or("en")) {
 		Some(language) => language,
-		None => return Err(exceptions::ValueError::py_err("Invalid language_code"))
+		None => return Err(exceptions::PyValueError::new_err("Invalid language_code"))
 	};
 
 	let mnemonic = match Mnemonic::from_phrase(phrase, language) {
 		Ok(some_mnemomic) => some_mnemomic,
-		Err(err) => return Err(exceptions::ValueError::py_err(format!("Invalid mnemonic: {}", err.to_string())))
+		Err(err) => return Err(exceptions::PyValueError::new_err(format!("Invalid mnemonic: {}", err.to_string())))
 	};
 	let mut result = [0u8; 64];
 
@@ -72,17 +72,17 @@
 ///
 /// A string containing the mnemonic words.
 #[pyfunction]
-#[text_signature = "(words, language_code, /)"]
+#[pyo3(text_signature = "(words, language_code, /)")]
 pub fn bip39_generate(words: u32, language_code: Option<&str>) -> PyResult<String> {
 
 	let language = match Language::from_language_code(language_code.unwrap_or("en")) {
 		Some(language) => language,
-		None => return Err(exceptions::ValueError::py_err("Invalid language_code"))
+		None => return Err(exceptions::PyValueError::new_err("Invalid language_code"))
 	};
 
 	let word_count_type = match MnemonicType::for_word_count(words as usize) {
 		Ok(some_work_count) => some_work_count,
-		Err(err) => return Err(exceptions::ValueError::py_err(err.to_string()))
+		Err(err) => return Err(exceptions::PyValueError::new_err(err.to_string()))
 	};
 
 	let phrase = Mnemonic::new(word_count_type, language).into_phrase();
@@ -104,17 +104,17 @@
 ///
 /// Returns a 32-bytes seed
 #[pyfunction]
-#[text_signature = "(phrase, password, language_code, /)"]
+#[pyo3(text_signature = "(phrase, password, language_code, /)")]
 pub fn bip39_to_seed(phrase: &str, password: &str, language_code: Option<&str>) -> PyResult<Vec<u8>> {
 
 	let language = match Language::from_language_code(language_code.unwrap_or("en")) {
 		Some(language) => language,
-		None => return Err(exceptions::ValueError::py_err("Invalid language_code"))
+		None => return Err(exceptions::PyValueError::new_err("Invalid language_code"))
 	};
 
 	let mnemonic = match Mnemonic::from_phrase(phrase, language) {
 		Ok(some_mnemomic) => some_mnemomic,
-		Err(err) => return Err(exceptions::ValueError::py_err(format!("Invalid mnemonic: {}", err.to_string())))
+		Err(err) => return Err(exceptions::PyValueError::new_err(format!("Invalid mnemonic: {}", err.to_string())))
 	};
 
 	Ok(Seed::new(&mnemonic, password)
@@ -134,11 +134,11 @@
 ///
 /// Returns boolean with validation result
 #[pyfunction]
-#[text_signature = "(phrase, language_code, /)"]
+#[pyo3(text_signature = "(phrase, language_code, /)")]
 pub fn bip39_validate(phrase: &str, language_code: Option<&str>) -> PyResult<bool> {
 	let language = match Language::from_language_code(language_code.unwrap_or("en")) {
 		Some(language) => language,
-		None => return Err(exceptions::ValueError::py_err("Invalid language_code"))
+		None => return Err(exceptions::PyValueError::new_err("Invalid language_code"))
 	};
 
 	match Mnemonic::validate(phrase, language) {
