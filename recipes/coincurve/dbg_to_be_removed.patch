--- setup.py	2023-12-21 12:57:24.286924157 -0600
+++ setup.py	2023-12-21 18:25:26.562846409 -0600
@@ -9,6 +9,7 @@
 from distutils.command.build_clib import build_clib as _build_clib
 from distutils.command.build_ext import build_ext as _build_ext
 from distutils.errors import DistutilsError
+from distutils.extension import Extension
 from io import BytesIO
 import sys
 
@@ -17,6 +18,8 @@
 from setuptools.command.egg_info import egg_info as _egg_info
 from setuptools.command.sdist import sdist as _sdist
 
+import pkgconfig
+
 try:
     from wheel.bdist_wheel import bdist_wheel as _bdist_wheel
 except ImportError:
@@ -221,10 +224,6 @@
 
             self.define = _build_clib.build_flags['define']
 
-        if os.name == 'nt' or sys.platform == 'win32':
-            # Apparently, the linker on Windows interprets -lxxx as xxx.lib, not libxxx.lib
-            self.libraries = [lib[1:] for lib in self.libraries if 'secp256k1' in lib]
-
         return _build_ext.run(self)
 
 
@@ -271,16 +270,48 @@
         },
     )
 
+if (os.name == 'nt' or sys.platform == 'win32') and has_system_lib():
+    class BuildCFFIForSharedLib(build_ext):
+        def build_extensions(self):
+            build_script = os.path.join('_cffi_build', 'build_shared.py')
+            c_file = self.extensions[0].sources[0]
+            python_exe = shutil.which('python', path=os.environ['PATH'])
+            subprocess.run([python_exe, build_script, c_file, '0'], shell=False, check=True)  # noqa S603
+            super().build_extensions()
+
+
+    # --- SECP256K1 package definitions ---
+    secp256k1_package = 'libsecp256k1'
+
+    extension = Extension(
+        name='coincurve._libsecp256k1',
+        sources=[os.path.join('coincurve', '_libsecp256k1.c')],
+        py_limited_api=True,
+    )
 
-setup(
-    long_description=open('README.md', 'r').read(),
-    long_description_content_type='text/markdown',
+    pkgconfig.configure_extension(extension, secp256k1_package, static=False)
+    package_info = pkgconfig.parse(secp256k1_package, static=False)
 
-    packages=find_packages(exclude=('_cffi_build', '_cffi_build.*', 'libsecp256k1', 'tests')),
-    package_data=package_data,
+    # Apparently, the linker on Windows interprets -lxxx as xxx.lib, not libxxx.lib
+    for i, v in enumerate(extension.__dict__.get('extra_link_args')):
+        if v.endswith('.lib'):
+            extension.__dict__['extra_link_args'][i] = f'lib{v}'
+
+    setup(
+        ext_modules=[extension],
+        cmdclass={'build_ext': BuildCFFIForSharedLib},
+        package_data=package_data,
+    )
+else:
+    setup(
+        long_description=open('README.md', 'r').read(),
+        long_description_content_type='text/markdown',
+
+        packages=find_packages(exclude=('_cffi_build', '_cffi_build.*', 'libsecp256k1', 'tests')),
+        package_data=package_data,
 
-    distclass=Distribution,
-    zip_safe=False,
+        distclass=Distribution,
+        zip_safe=False,
 
-    **setup_kwargs
-)
+        **setup_kwargs
+    )
--- /dev/null	2023-12-15 11:32:31.319245056 -0600
+++ _cffi_build/build_shared.py	2023-12-21 18:24:17.017770476 -0600
@@ -0,0 +1,84 @@
+import argparse
+import logging
+import os
+from collections import namedtuple
+from typing import List
+
+from cffi import FFI
+
+logging.basicConfig(level=logging.INFO)
+
+here = os.path.dirname(os.path.abspath(__file__))
+
+Source = namedtuple('Source', ('h', 'include'))
+
+
+def gather_sources_from_directory(directory: str) -> List[Source]:
+    """
+    Gather source files from a given directory.
+
+    :param directory: The directory where source files are located.
+    :return: A list of Source namedtuples.
+    """
+    sources = []
+    for filename in os.listdir(directory):
+        if filename.endswith('.h'):
+            include_line = f'#include <{filename}>'
+            sources.append(Source(filename, include_line))
+    return sorted(sources)
+
+
+define_static_lib = """
+#if defined(_WIN32)
+#   define SECP256K1_STATIC 1
+#   define SECP256K1_API extern __declspec(dllexport)
+#endif
+"""
+
+define_shared_lib = """
+#if defined(_WIN32)
+#   define SECP256K1_API extern __declspec(dllimport)
+#endif
+"""
+
+
+def mk_ffi(sources: List[Source],
+           static_lib: str = '0',
+           name: str = '_libsecp256k1') -> FFI:
+    """
+    Create an FFI object.
+
+    :param sources: A list of Source namedtuples.
+    :param libraries: A list of libraries to link against.
+    :param static_lib: Whether to generate a static lib in Windows.
+    :param name: The name of the FFI object.
+    :return: An FFI object.
+    """
+    _ffi = FFI()
+    code = [define_static_lib] if static_lib == '1' else [define_shared_lib]
+
+    for source in sources:
+        with open(os.path.join(here, source.h)) as h:
+            logging.info(f'   Including {source.h}...')
+            c_header = h.read().replace('SECP256K1_API', '')
+            _ffi.cdef(c_header)
+
+        code.append(source.include)
+
+    code.append('#define PY_USE_BUNDLED')
+    _ffi.set_source(name, '\n'.join(code))
+
+    return _ffi
+
+
+if __name__ == '__main__':
+    logging.info('Starting CFFI build process...')
+    parser = argparse.ArgumentParser(description='Generate C code using CFFI.')
+    parser.add_argument('c_file', help='Generated C code filename.')
+    parser.add_argument('static_lib', help='Generate static lib in Windows.', default=False)
+    args = parser.parse_args()
+
+    modules = gather_sources_from_directory(here)
+    ffi = mk_ffi(modules, args.static_lib)
+    ffi.emit_c_code(args.c_file)
+    logging.info(f'   Generated C code: {args.c_file}')
