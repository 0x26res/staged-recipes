diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..1006453
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+rockstar-galaxies
+*.o
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..2edf4ef
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,92 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 3.12)
+project(
+  ROCKSTAR
+  LANGUAGES C
+)
+
+# Include the directory itself as a path to include directories
+set(CMAKE_INCLUDE_CURRENT_DIR ON)
+
+include_directories(/usr/include/tirpc)
+
+
+if (NOT CMAKE_BUILD_TYPE)
+  set (CMAKE_BUILD_TYPE Release)
+endif()
+
+# Set C standard
+set(CMAKE_C_STANDARD 99)
+
+# Detect hdf5
+find_package(HDF5 REQUIRED COMPONENTS C)
+if (HDF5_FOUND)
+  add_compile_definitions(H5_USE_16_API ENABLE_HDF5)
+  link_libraries(HDF5::HDF5)
+endif()
+
+
+# add_compile_definitions(H5_USE_16_API ENABLE_HDF5)
+add_compile_definitions(_LARGEFILE_SOURCE _LARGEFILE64_SOURCE _FILE_OFFSET_BITS=64 _DEFAULT_SOURCE _POSIX_SOURCE _POSIX_C_SOURCE=200809L _DARWIN_C_SOURCE)
+add_compile_options(-fPIC -fno-math-errno -Wall -m64 -Og)
+add_link_options(-fPIC)
+
+# Create executable
+include_directories("${PROJECT_SOURCE_DIR}")
+include_directories("${PROJECT_SOURCE_DIR}/io")
+include_directories("${PROJECT_SOURCE_DIR}/inet")
+
+project(ROCKSTAR C)
+
+set(SOURCES
+  main.c 
+  rockstar.c 
+  check_syscalls.c 
+  fof.c 
+  groupies.c 
+  subhalo_metric.c 
+  potential.c 
+  nfw.c 
+  jacobi.c 
+  fun_times.c 
+  interleaving.c 
+  universe_time.c 
+  hubble.c 
+  integrate.c 
+  distance.c 
+  config_vars.c 
+  config.c 
+  bounds.c 
+  inthash.c 
+  client.c 
+  server.c 
+  merger.c 
+  io/read_config.c 
+  inet/socket.c 
+  inet/rsocket.c 
+  inet/address.c 
+  io/meta_io.c 
+  io/io_internal.c 
+  io/io_ascii.c 
+  io/stringparse.c 
+  io/io_gadget.c 
+  io/io_generic.c 
+  io/io_art.c 
+  io/io_nchilada.c 
+  io/io_tipsy.c 
+  io/io_bgc2.c 
+  io/io_util.c 
+  io/io_arepo.c 
+  io/io_hdf5.c 
+  io/io_enzo.c 
+)
+
+# Generate "rockstar-galaxies" executable
+add_executable(rockstar-galaxies ${SOURCES})
+target_link_libraries(rockstar-galaxies tirpc m)
+
+# Generate "librockstar-galaxies.so" shared library
+add_library(lib SHARED ${SOURCES})
+target_link_libraries(lib tirpc m)
+set_target_properties(lib PROPERTIES OUTPUT_NAME "rockstar-galaxies")
+
+install(TARGETS rockstar-galaxies lib)
diff --git a/Makefile b/Makefile
index 66f7e17..39b44cf 100644
--- a/Makefile
+++ b/Makefile
@@ -1,56 +1,74 @@
-CFLAGS=-m64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -D_BSD_SOURCE -D_POSIX_SOURCE -D_POSIX_C_SOURCE=200809L -D_SVID_SOURCE -D_DARWIN_C_SOURCE -Wall -fno-math-errno -fPIC
+CFLAGS=-m64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -D_DEFAULT_SOURCE -D_POSIX_SOURCE -D_POSIX_C_SOURCE=200809L -D_DARWIN_C_SOURCE -Wall -fno-math-errno -fPIC -I/usr/include/tirpc
+# CFLAGS=-D_DARWIN_C_SOURCE -D_DEFAULT_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200809L -D_POSIX_SOURCE -I/home/cphyc/Documents/prog/rockstar-galaxies/build -I/home/cphyc/Documents/prog/rockstar-galaxies -I/usr/include/tirpc -I/home/cphyc/Documents/prog/rockstar-galaxies/io -I/home/cphyc/Documents/prog/rockstar-galaxies/inet -O3 -DNDEBUG -std=gnu99 -fPIC -fno-math-errno -Wall -m64 -Og -MD
 LDFLAGS=-shared
-OFLAGS = -lm -O3 -std=c99
+OFLAGS = -lm -ltirpc -O3 -std=c99
 DEBUGFLAGS = -lm -g -O3 -std=c99 #-Dinline= 
 PROFFLAGS = -lm -g -pg -O2 -std=c99
 CC = gcc
 CFILES = rockstar.c check_syscalls.c fof.c groupies.c subhalo_metric.c potential.c nfw.c jacobi.c fun_times.c interleaving.c universe_time.c hubble.c integrate.c distance.c config_vars.c config.c bounds.c inthash.c io/read_config.c client.c server.c merger.c inet/socket.c inet/rsocket.c inet/address.c io/meta_io.c io/io_internal.c io/io_ascii.c io/stringparse.c io/io_gadget.c io/io_generic.c io/io_art.c io/io_nchilada.c io/io_tipsy.c io/io_bgc2.c io/io_util.c io/io_arepo.c io/io_hdf5.c io/io_enzo.c
+OFILES = main.o rockstar.o check_syscalls.o fof.o groupies.o subhalo_metric.o potential.o nfw.o jacobi.o fun_times.o interleaving.o universe_time.o hubble.o integrate.o distance.o config_vars.o config.o bounds.o inthash.o client.o server.o merger.o io/read_config.o inet/socket.o inet/rsocket.o inet/address.o io/meta_io.o io/io_internal.o io/io_ascii.o io/stringparse.o io/io_gadget.o io/io_generic.o io/io_art.o io/io_nchilada.o io/io_tipsy.o io/io_bgc2.o io/io_util.o io/io_arepo.o io/io_hdf5.o io/io_enzo.o
 DIST_FLAGS =
-HDF5_FLAGS = -DH5_USE_16_API -lhdf5 -DENABLE_HDF5 -I/opt/local/include -L/opt/local/lib
+HDF5_FLAGS = -DH5_USE_16_API -lhdf5 -DENABLE_HDF5 -I${HDF5_LIB}/include -L${HDF5_LIB}/lib
+HDF5 = 0
 
-all:
-	@make reg EXTRA_FLAGS="$(OFLAGS)"
+ifeq ($(HDF5),1)
+OFLAGS += $(HDF5_FLAGS)
+endif
 
-with_hdf5:
-	@make reg EXTRA_FLAGS="$(OFLAGS) $(HDF5_FLAGS)"
+all: rockstar-galaxies
 
-debug:
-	@make reg EXTRA_FLAGS="$(DEBUGFLAGS)"
+rockstar-galaxies: $(OFILES)
+	$(CC) $(CFLAGS) $(OFILES) -o rockstar-galaxies $(OFLAGS) $(EXTRA_FLAGS)
 
-with_hdf5_debug:
-	@make reg EXTRA_FLAGS="$(DEBUGFLAGS) $(HDF5_FLAGS)"
+%.o: %.c
+	$(CC) $(CFLAGS) $(OFLAGS) -c $*.c -o $@
 
-prof:
-	@make reg EXTRA_FLAGS="$(PROFFLAGS)"
+#all:
+#	@make reg EXTRA_FLAGS="$(OFLAGS)"
 
-.REMAKE:
+# with_hdf5:
+# 	@make reg EXTRA_FLAGS="$(OFLAGS) $(HDF5_FLAGS)"
 
-dist: .REMAKE
-	cd ../ ; perl -ne 'print "$$1\n" if (/VERSION\s*\"([^\"]+)/)' Rockstar-Galaxies/version.h > Rockstar-Galaxies/VERSION; tar -czvf rockstar-galaxies.tar.gz Rockstar-Galaxies/Makefile Rockstar-Galaxies/*.[ch] Rockstar-Galaxies/examples/Makefile Rockstar-Galaxies/[^sto]*/*.[ch] Rockstar-Galaxies/quickstart.cfg Rockstar-Galaxies/parallel.cfg Rockstar-Galaxies/scripts/*.pbs Rockstar-Galaxies/scripts/*.cfg Rockstar-Galaxies/scripts/*.pl Rockstar-Galaxies/SOURCE_LAYOUT Rockstar-Galaxies/README.pdf Rockstar-Galaxies/README Rockstar-Galaxies/LICENSE Rockstar-Galaxies/VERSION Rockstar-Galaxies/ACKNOWLEDGMENTS Rockstar-Galaxies/CHANGELOG; mv rockstar-galaxies.tar.gz Rockstar-Galaxies
+# debug:
+# 	@make reg EXTRA_FLAGS="$(DEBUGFLAGS)"
 
-versiondist:
-	$(MAKE) dist DIST_FLAGS="$(DIST_FLAGS)"
-	rm -rf dist
-	mkdir dist
-	cd dist; tar xzf ../rockstar-galaxies.tar.gz ; perl -ne '/\#define.*VERSION\D*([\d\.rcRC-]+)/ && print $$1' Rockstar-Galaxies/version.h > NUMBER ; mv Rockstar-Galaxies Rockstar-Galaxies-`cat NUMBER`; tar czf rockstar-galaxies-`cat NUMBER`.tar.gz Rockstar-Galaxies-`cat NUMBER`
+# with_hdf5_debug:
+# 	@make reg EXTRA_FLAGS="$(DEBUGFLAGS) $(HDF5_FLAGS)"
 
-reg:
-	$(CC) $(CFLAGS) main.c $(CFILES) -o rockstar-galaxies  $(EXTRA_FLAGS)
+# prof:
+# 	@make reg EXTRA_FLAGS="$(PROFFLAGS)"
+
+# .REMAKE:
+
+# dist: .REMAKE
+# 	cd ../ ; perl -ne 'print "$$1\n" if (/VERSION\s*\"([^\"]+)/)' Rockstar-Galaxies/version.h > Rockstar-Galaxies/VERSION; tar -czvf rockstar-galaxies.tar.gz Rockstar-Galaxies/Makefile Rockstar-Galaxies/*.[ch] Rockstar-Galaxies/examples/Makefile Rockstar-Galaxies/[^sto]*/*.[ch] Rockstar-Galaxies/quickstart.cfg Rockstar-Galaxies/parallel.cfg Rockstar-Galaxies/scripts/*.pbs Rockstar-Galaxies/scripts/*.cfg Rockstar-Galaxies/scripts/*.pl Rockstar-Galaxies/SOURCE_LAYOUT Rockstar-Galaxies/README.pdf Rockstar-Galaxies/README Rockstar-Galaxies/LICENSE Rockstar-Galaxies/VERSION Rockstar-Galaxies/ACKNOWLEDGMENTS Rockstar-Galaxies/CHANGELOG; mv rockstar-galaxies.tar.gz Rockstar-Galaxies
+
+# versiondist:
+# 	$(MAKE) dist DIST_FLAGS="$(DIST_FLAGS)"
+# 	rm -rf dist
+# 	mkdir dist
+# 	cd dist; tar xzf ../rockstar-galaxies.tar.gz ; perl -ne '/\#define.*VERSION\D*([\d\.rcRC-]+)/ && print $$1' Rockstar-Galaxies/version.h > NUMBER ; mv Rockstar-Galaxies Rockstar-Galaxies-`cat NUMBER`; tar czf rockstar-galaxies-`cat NUMBER`.tar.gz Rockstar-Galaxies-`cat NUMBER`
+
+# reg:
+# 	$(CC) $(CFLAGS) main.c $(CFILES) -o rockstar-galaxies  $(EXTRA_FLAGS)
 
 lib:
 	$(CC) $(CFLAGS) $(LDFLAGS) $(CFILES) -o librockstar-galaxies.so $(OFLAGS)
 
-bgc2:
-	$(CC) $(CFLAGS) io/extra_bgc2.c util/redo_bgc2.c $(CFILES) -o util/finish_bgc2  $(OFLAGS)
-	$(CC) $(CFLAGS) io/extra_bgc2.c util/bgc2_to_ascii.c $(CFILES) -o util/bgc2_to_ascii  $(OFLAGS)
+# lib_with_hdf5:
+# 	$(CC) $(CFLAGS) $(LDFLAGS) $(CFILES) -o librockstar-galaxies.so $(OFLAGS)  $(HDF5_FLAGS)
+
+# bgc2:
+# 	$(CC) $(CFLAGS) io/extra_bgc2.c util/redo_bgc2.c $(CFILES) -o util/finish_bgc2  $(OFLAGS)
+# 	$(CC) $(CFLAGS) io/extra_bgc2.c util/bgc2_to_ascii.c $(CFILES) -o util/bgc2_to_ascii  $(OFLAGS)
 
-parents:
-	$(CC) $(CFLAGS) util/find_parents.c io/stringparse.c check_syscalls.c  -o util/find_parents $(OFLAGS)
+# parents:
+# 	$(CC) $(CFLAGS) util/find_parents.c io/stringparse.c check_syscalls.c  -o util/find_parents $(OFLAGS)
 
-substats:
-	$(CC) $(CFLAGS) util/subhalo_stats.c $(CFILES) -o util/subhalo_stats  $(OFLAGS)
+# substats:
+# 	$(CC) $(CFLAGS) util/subhalo_stats.c $(CFILES) -o util/subhalo_stats  $(OFLAGS)
 
 
 clean:
-	rm -f *~ io/*~ inet/*~ util/*~ rockstar-galaxies util/redo_bgc2 util/subhalo_stats
+	rm -f *~ io/*~ inet/*~ util/*~ rockstar-galaxies util/redo_bgc2 util/subhalo_stats *.o io/*.o
 
diff --git a/client.c b/client.c
index 156c4c3..c08cfdf 100644
--- a/client.c
+++ b/client.c
@@ -29,7 +29,7 @@
 #include "interleaving.h"
 #include "config.h"
 
-#define CLIENT_DEBUG 0
+#define CLIENT_DEBUG 1
 
 extern struct rsocket *rsockets;
 
@@ -914,7 +914,6 @@ void accept_workloads(char *c_address, char *c_port, int64_t snap, int64_t chunk
       total_h += num_halos;
       total_wku++;
 
-      //      fprintf(stderr, "Workunit done (%"PRId64" halos found; %"PRId64" chunks)!!!\n", num_halos, num_chunks);
       for (i=0; i<num_halos; i++) wrap_into_box(halos[i].pos);
       for (i=0; i<num_chunks; i++) {
 	struct fof *chunk_fofs=NULL;
diff --git a/config.template.h b/config.template.h
index c845386..36c124f 100644
--- a/config.template.h
+++ b/config.template.h
@@ -39,6 +39,8 @@ real(AREPO_MASS_CONVERSION, 1e10);
 real(AREPO_LENGTH_CONVERSION, 1e-3);
 real(AREPO_VELOCITY_CONVERSION, 1.0);
 integer(AREPO_DM_PARTTYPE, 1);
+integer(ENZO_ZOOMIN_RESTRICT, 0);
+integer(ENZO_PARTICLE_SPLITTING, 0);
 #endif /* ENABLE_HDF5 */
 
 real(TIPSY_LENGTH_CONVERSION, 1.0);
diff --git a/fast3tree.c b/fast3tree.c
index 2a94943..f4c6e67 100644
--- a/fast3tree.c
+++ b/fast3tree.c
@@ -127,7 +127,7 @@ static inline void fast3tree_find_sphere(struct fast3tree *t,
 
 #undef fast3tree_find_sphere_skip
 #define fast3tree_find_sphere_skip _F3TN(FAST3TREE_PREFIX,fast3tree_find_sphere_skip)
-inline void fast3tree_find_sphere_skip(struct fast3tree *t,
+extern inline void fast3tree_find_sphere_skip(struct fast3tree *t,
 		  struct fast3tree_results *res, FAST3TREE_TYPE *tp, float r);
 
 #undef fast3tree_find_sphere_periodic
@@ -442,7 +442,7 @@ static inline void fast3tree_find_sphere(struct fast3tree *t, struct fast3tree_r
   _fast3tree_find_sphere(t->root, res, c, r);
 }
 
-inline void fast3tree_find_sphere_skip(struct fast3tree *t, struct fast3tree_results *res, FAST3TREE_TYPE *tp, float r) {
+extern inline void fast3tree_find_sphere_skip(struct fast3tree *t, struct fast3tree_results *res, FAST3TREE_TYPE *tp, float r) {
   res->num_points = 0;
   _fast3tree_find_sphere_skip(t->root, res, tp->pos, r, tp);
 }
diff --git a/fun_times.h b/fun_times.h
index 0dd1355..10397cd 100644
--- a/fun_times.h
+++ b/fun_times.h
@@ -15,7 +15,7 @@ struct prev_bounds {
   float bounds[6];
 };
 
-struct prev_bounds *p_bounds;
+extern struct prev_bounds *p_bounds;
 extern int64_t prev_snap;
 
 #define MAX_CORE_PARTICLES 10000
diff --git a/groupies.c b/groupies.c
index 34f9fd7..1856d26 100644
--- a/groupies.c
+++ b/groupies.c
@@ -923,7 +923,7 @@ int64_t rad_partition(float *rad, int64_t left, int64_t right, int64_t pivot_ind
 #undef SWAP
 }
 
-inline float random_unit(void) {
+extern inline float random_unit(void) {
   return(((float)(rand()%(RAND_MAX))/(float)(RAND_MAX)));
 }
 
diff --git a/halo.h b/halo.h
index f842679..0b0685b 100644
--- a/halo.h
+++ b/halo.h
@@ -1,7 +1,7 @@
 #ifndef HALO_H
 #define HALO_H
 
-#define HALO_FORMAT_REVISION 1
+#define HALO_FORMAT_REVISION 2
 
 #include <stdint.h>
 
diff --git a/interleaving.h b/interleaving.h
index 1d3894b..1537887 100644
--- a/interleaving.h
+++ b/interleaving.h
@@ -18,7 +18,7 @@ struct bgroup {
 
 extern int64_t num_new_bp;
 extern struct bgroup *bg;
-struct bgroup *final_bg;
+extern struct bgroup *final_bg;
 extern int64_t num_bg_sets;
 extern int64_t *bg_set_sizes;
 extern int64_t *bg_set_indices;
diff --git a/inthash.c b/inthash.c
index aeda489..64234b8 100644
--- a/inthash.c
+++ b/inthash.c
@@ -40,7 +40,7 @@ int64_t *ih_keylist(struct inthash *ih) {
 }
 
 
-inline uint64_t _ih_hash_function(struct inthash *ih, uint64_t key) {
+extern inline uint64_t _ih_hash_function(struct inthash *ih, uint64_t key) {
   return ((key*ih->hashnum)>>(64 - ih->hashwidth));
 }
 
@@ -81,7 +81,7 @@ void ih_prealloc(struct inthash *ih, int64_t size) {
   _ih_add_more_buckets(ih, numbits-ih->hashwidth);
 }
 
-inline struct intbucket *_ih_getval(struct inthash *ih, int64_t key) {
+extern inline struct intbucket *_ih_getval(struct inthash *ih, int64_t key) {
   struct intbucket *ib = ih->buckets + _ih_hash_function(ih, key);
   int64_t key2 = key;
   while (ib->key!=IH_INVALID) {
@@ -92,7 +92,7 @@ inline struct intbucket *_ih_getval(struct inthash *ih, int64_t key) {
   return ib;
 }
 
-inline struct intbucket *_ih_getval_deleted(struct inthash *ih, int64_t key) {
+extern inline struct intbucket *_ih_getval_deleted(struct inthash *ih, int64_t key) {
   struct intbucket *ib = ih->buckets + _ih_hash_function(ih, key);
   struct intbucket *ib_del = NULL;
   int64_t key2 = key;
diff --git a/io/bgc2.h b/io/bgc2.h
index 3387d77..99ac6c2 100644
--- a/io/bgc2.h
+++ b/io/bgc2.h
@@ -116,7 +116,7 @@ typedef struct {
 
 /* Get the size of the GROUP DATA (gdata) structure based on FORMAT number */
 #ifdef BGC2_SIZE
-inline size_t
+extern inline size_t
 bgc_sizeof_gdata( const int64_t gdata_format )
 {
     switch ( gdata_format ) {
@@ -149,7 +149,7 @@ enum pdata_format {
 };
 
 #ifdef BGC2_SIZE
-inline int
+extern inline int
 bgc_format_includes_be( int64_t format_id )
 {
     /* this MUST be kept in sync with the above enum defining the formats */
@@ -215,7 +215,7 @@ typedef struct {
 
 /* Get the size of the PARTICLE DATA (pdata) structure based on FORMAT number */
 #ifdef BGC2_SIZE
-inline size_t
+extern inline size_t
 bgc_sizeof_pdata( const int64_t pdata_format )
 {
     switch ( pdata_format ) {
diff --git a/io/io_bgc2.c b/io/io_bgc2.c
index 2b5b97a..d338f08 100644
--- a/io/io_bgc2.c
+++ b/io/io_bgc2.c
@@ -95,7 +95,7 @@ struct fast3tree *ep_tree, *ep_tree2=NULL;
 struct fast3tree_results *ep_res;
 float ep_old_minmax[6];
 
-inline void insertion_sort_extended_particles(int64_t min, int64_t max,
+extern inline void insertion_sort_extended_particles(int64_t min, int64_t max,
                 struct extended_particle **particles, float *radii) {
   int64_t i, pos;
   float r;
diff --git a/io/io_enzo.c b/io/io_enzo.c
index e962802..0699880 100644
--- a/io/io_enzo.c
+++ b/io/io_enzo.c
@@ -44,15 +44,15 @@ int sort_enzo_grids(const void *a, const void *b) {
 }
 
 /************************************************************************/
-void enzo_load_cosmology (char *filename)
+void enzo_load_cosmology (char *filename, int32_t *max_static_level)
 {
 
   FILE 	*input;
   char 	 buffer[1024];
   float  redshift, initialRedshift;
-  int64_t 	 dummy;
+  int64_t dummy;
   int64_t    TopGrid[3];
-  int32_t CycleNumber;
+  int32_t CycleNumber, temp_level, region;
   double Time;
   double Ob = 0.06; //Default for ENZO
 
@@ -73,16 +73,26 @@ void enzo_load_cosmology (char *filename)
     sscanf(buffer, "CosmologyInitialRedshift = %f", &initialRedshift);
     sscanf(buffer, "CosmologyCurrentRedshift = %f", &redshift);
     sscanf(buffer, "#DataCGSConversionFactor[3] = %lg %*s", &EnzoVelocityUnit);
+    if (sscanf(buffer, "StaticRefineRegionLevel[%d] = %d", &region, &temp_level) == 2)
+      if (temp_level+1 > *max_static_level)
+	*max_static_level = temp_level+1;
   }  // END line read
 
   fclose(input);
 
+  if (ENZO_ZOOMIN_RESTRICT)
+    PERIODIC = 0;
+  else
+    *max_static_level = 0;
+
   /********** Convert to GADGET units **********/
 
   // rho_crit * omega_M * (comoving_boxsize / rootgrid_reso)^3
-  EnzoMassUnit = PARTICLE_MASS = Om * CRITICAL_DENSITY * pow(BOX_SIZE, 3) /
+  EnzoMassUnit = Om * CRITICAL_DENSITY * pow(BOX_SIZE, 3) /
     (TopGrid[0] * TopGrid[1] * TopGrid[2]);
-
+  PARTICLE_MASS = EnzoMassUnit / pow(8.0, *max_static_level) /
+    pow(13.0, ENZO_PARTICLE_SPLITTING);
+  
   if (RESCALE_PARTICLE_MASS) EnzoMassUnit *= Om / (Om - Ob + 1e-20);
   AVG_PARTICLE_SPACING = cbrt(PARTICLE_MASS / (Om*CRITICAL_DENSITY));
   SCALE_NOW = 1.0 / (1.0 + redshift);    // Time = a
@@ -99,7 +109,8 @@ void enzo_load_cosmology (char *filename)
       EnzoNumFiles++;
   }  // END file line read
   fclose(input);
-  //fprintf(stderr, "Grids = %"PRId64"\n", EnzoNumFiles);
+//  fprintf(stderr, "Grids = %"PRId64", PARTICLE_MASS = %g, max_static_level = %d\n", 
+//	  EnzoNumFiles, PARTICLE_MASS, *max_static_level);
 }
 
 /************************************************************************/
@@ -107,11 +118,13 @@ void enzo_load_cosmology (char *filename)
 void load_particles_enzo(char *filename, struct particle **p, int64_t *num_p) {
 
   char buffer[1024];
-  int64_t i, dim, dummy, grid;
+  int64_t i, dim, dummy, grid, nfine;
+  int32_t max_static_level = 0;
+  struct EnzoGrid *all_grids = NULL;
   struct EnzoGrid *grids = NULL;
   int64_t startIndex, endIndex;
   float GridLeftEdge[3], GridRightEdge[3];
-  float	cellWidth, rootCellWidth=1;
+  float	cellWidth=1, rootCellWidth=1;
 
   int64_t length = strlen(filename);
   int64_t block = 0;
@@ -124,9 +137,9 @@ void load_particles_enzo(char *filename, struct particle **p, int64_t *num_p) {
     block = atol(filename+length+1);
   }
 
-  enzo_load_cosmology(filename);
-  check_realloc_s(grids, sizeof(struct EnzoGrid), EnzoNumFiles);
-  memset(grids, 0, sizeof(struct EnzoGrid)*EnzoNumFiles);
+  enzo_load_cosmology(filename, &max_static_level);
+  check_realloc_s(all_grids, sizeof(struct EnzoGrid), EnzoNumFiles);
+  memset(all_grids, 0, sizeof(struct EnzoGrid)*EnzoNumFiles);
 
   /******** Get particle counts and levels in each grid ********/
   snprintf(buffer, 1024, "%s.hierarchy", filename);
@@ -134,10 +147,11 @@ void load_particles_enzo(char *filename, struct particle **p, int64_t *num_p) {
   //printf("load_particles_enzo: parsing hierarchy file ...\n");
 
   grid = 0;
+  nfine = 0;
   while (fgets(buffer, 1024, hf)) {
     if (sscanf(buffer, "Grid = %"SCNd64, &dummy) == 1) {
       grid = dummy-1;
-      grids[grid].id = dummy;
+      all_grids[grid].id = dummy;
     }
     sscanf(buffer, "GridStartIndex = %"SCNd64, &startIndex);
     sscanf(buffer, "GridEndIndex = %"SCNd64, &endIndex);
@@ -149,19 +163,38 @@ void load_particles_enzo(char *filename, struct particle **p, int64_t *num_p) {
       // Calculate and store grid level
       cellWidth = (GridRightEdge[0] - GridLeftEdge[0]) / (endIndex - startIndex + 1);
       if (grid == 0) rootCellWidth = cellWidth;
-      grids[grid].level = log2(rootCellWidth / cellWidth) + 0.5;
-      grids[grid].num_p = dummy;
+      all_grids[grid].level = log2(rootCellWidth / cellWidth) + 0.5;
+      if (all_grids[grid].level >= max_static_level) nfine++;
+      all_grids[grid].num_p = dummy;
     }
 
     if (!strncmp(buffer, "ParticleFileName = ", 19)) {
-      grids[grid].fname = strdup(buffer + 19);
-      char *end = grids[grid].fname+strlen(grids[grid].fname);
-      if (end > grids[grid].fname && end[-1]=='\n')
+      all_grids[grid].fname = strdup(buffer + 19);
+      char *end = all_grids[grid].fname+strlen(all_grids[grid].fname);
+      if (end > all_grids[grid].fname && end[-1]=='\n')
 	end[-1] = 0;
     }
   }
   fclose(hf);
 
+  // Copy grids with level > max_static_level to the restricted
+  // grid & particle dataset
+  if (max_static_level > 0) {
+    check_realloc_s(grids, sizeof(struct EnzoGrid), nfine);
+    memset(grids, 0, sizeof(struct EnzoGrid)*nfine);
+    for (i = 0, grid = 0; i < EnzoNumFiles; i++)
+      if (all_grids[i].level >= max_static_level) {
+	memcpy(grids+grid, all_grids+i, sizeof(struct EnzoGrid));
+	if (all_grids[i].fname) strcpy(grids[grid].fname, all_grids[i].fname);
+	grid++;
+      } else {
+	if (all_grids[i].fname) free(all_grids[i].fname);
+      }
+    EnzoNumFiles = nfine;
+  } else {
+    grids = all_grids;
+  }
+
   qsort(grids, EnzoNumFiles, sizeof(struct EnzoGrid), sort_enzo_grids);
 
   // Particle HDF labels
@@ -240,20 +273,21 @@ void load_particles_enzo(char *filename, struct particle **p, int64_t *num_p) {
 
   for (i=0; i<EnzoNumFiles; i++) 
     if (grids[i].fname) free(grids[i].fname);
+  if (grids != all_grids) free(all_grids);
   free(grids);
   //printf("Particles read: %"PRId64"\n", total_read);
 
   if (NUM_BLOCKS > 1) filename[length] = '.';
   snprintf(buffer, 1024, "particles.%"PRId64".ascii", block);
-  FILE *output = check_fopen(buffer, "w");
-  fprintf(output, "#X Y Z VX VY VZ Mass Energy ID Type\n");
-  for (i=0; i<*num_p; i++) {
-    fprintf(output, "%f %f %f %f %f %f %f %f %"PRId64" %d\n",
-	    p[0][i].pos[0], p[0][i].pos[1], p[0][i].pos[2], 
-	    p[0][i].pos[3], p[0][i].pos[4], p[0][i].pos[5], 
-	    p[0][i].mass, p[0][i].energy, p[0][i].id, p[0][i].type); 
-  }
-  fclose(output);
+  //FILE *output = check_fopen(buffer, "w");
+  //fprintf(output, "#X Y Z VX VY VZ Mass Energy ID Type\n");
+  //for (i=0; i<*num_p; i++) {
+  //  fprintf(output, "%f %f %f %f %f %f %f %f %"PRId64" %d\n",
+  //	    p[0][i].pos[0], p[0][i].pos[1], p[0][i].pos[2], 
+  //	    p[0][i].pos[3], p[0][i].pos[4], p[0][i].pos[5], 
+  //	    p[0][i].mass, p[0][i].energy, p[0][i].id, p[0][i].type); 
+  //}
+  //fclose(output);
 }
 
 
diff --git a/io/io_internal.c b/io/io_internal.c
index adf6a94..89bccf3 100644
--- a/io/io_internal.c
+++ b/io/io_internal.c
@@ -72,12 +72,12 @@ void load_particles_internal(char *filename, struct particle **part, int64_t *nu
 }
 
 
-inline void _clear_buffer(FILE *output) {
+extern inline void _clear_buffer(FILE *output) {
   check_fwrite(output_buffer, buffered, 1, output);
   buffered = 0;
 }
 
-inline void _append_to_buffer(void *src, int64_t size, FILE *output) {
+extern inline void _append_to_buffer(void *src, int64_t size, FILE *output) {
   if (buffered + size > OUTPUT_BUFFER_SIZE) _clear_buffer(output);
   if (size > OUTPUT_BUFFER_SIZE) { check_fwrite(src, size, 1, output); return; }
   memcpy(((char *)output_buffer)+buffered, src, size);
diff --git a/io/io_tipsy.c b/io/io_tipsy.c
index 5786948..012fc06 100644
--- a/io/io_tipsy.c
+++ b/io/io_tipsy.c
@@ -34,7 +34,7 @@ void load_particles_tipsy(char *filename, struct particle **p, int64_t *num_p) {
   struct tipsy_star_particle star;
   struct tipsy_gas_particle gas;
 
-  int i, j;
+  int i, j, result;
   int xdrfmt=1,haveiords=0;
   int *iords=NULL;
   XDR xdrs;
@@ -58,8 +58,10 @@ void load_particles_tipsy(char *filename, struct particle **p, int64_t *num_p) {
   haveiords = load_ids_tipsy(filename,header,&iords);
 
   for(i = 0; i < header.nsph; i++) {
-    if (xdrfmt) assert(tipsy_xdr_gas(&xdrs, &gas) > 0);
-    else fread((char *)&gas,sizeof(struct tipsy_gas_particle), 1, input) ;
+    if (xdrfmt) 
+      assert(tipsy_xdr_gas(&xdrs, &gas) > 0);
+    else
+      result = fread((char *)&gas,sizeof(struct tipsy_gas_particle), 1, input) ;
     for (j=0; j<3; j++) {
       if (haveiords) (*p)[i+(*num_p)].id = iords[i];
       else (*p)[i+(*num_p)].id = i;
@@ -94,8 +96,10 @@ void load_particles_tipsy(char *filename, struct particle **p, int64_t *num_p) {
 
   for(i = 0; i < header.nstar; i++) {
     int ip = i+header.nsph+header.ndark;
-    if (xdrfmt) assert(tipsy_xdr_star(&xdrs, &star) > 0);
-    else fread((char *)&star,sizeof(struct tipsy_star_particle), 1, input);
+    if (xdrfmt)
+      assert(tipsy_xdr_star(&xdrs, &star) > 0);
+    else
+      result = fread((char *)&star,sizeof(struct tipsy_star_particle), 1, input);
     for (j=0; j<3; j++) {
       if (haveiords) (*p)[i+(*num_p)].id = iords[ip];
       else (*p)[i+(*num_p)].id = ip;
diff --git a/io/io_util.c b/io/io_util.c
index 4e1a249..d94ae5f 100644
--- a/io/io_util.c
+++ b/io/io_util.c
@@ -33,7 +33,8 @@ size_t fread_swap(void *ptr, size_t size, size_t nitems, FILE *stream) {
   int8_t *e = ptr;
   n = check_fread(ptr, size, nitems, stream);
   if (!(size % 4))
-    for (i=0; i<(n*size); i+=4) swap_endian_4byte(e+i);  return n;
+    for (i=0; i<(n*size); i+=4) swap_endian_4byte(e+i);
+  return n;
 }
 
 size_t fread_swap8(void *ptr, size_t size, size_t nitems, FILE *stream) {
diff --git a/io/meta_io.c b/io/meta_io.c
index f5af5b3..00c37b3 100644
--- a/io/meta_io.c
+++ b/io/meta_io.c
@@ -63,7 +63,11 @@ void get_input_filename(char *buffer, int maxlen, int64_t snap, int64_t block) {
   assert(snap < NUM_SNAPS);
   snprintf(buffer, maxlen, "%s/", INBASE);
   out=strlen(buffer);
-  for (; (i<l)&&(out < (maxlen-1)); i++) {
+  if (snapnames) {
+    snprintf(buffer+out, maxlen-out, "%s", snapnames[snap]);
+    out=strlen(buffer);
+  }
+  for (; (i<l)&&(out < (maxlen-1)&&(!snapnames)); i++) {
     if (FILENAME[i] != '<') { buffer[out]=FILENAME[i]; buffer[out+1]=0; }
     else {
       if (!strncmp(FILENAME+i, "<snap>", 6)) {
@@ -99,9 +103,22 @@ void get_input_filename(char *buffer, int maxlen, int64_t snap, int64_t block) {
 
 void get_output_filename(char *buffer, int maxlen, int64_t snap, int64_t chunk, char *type) {
   int64_t out = 0;
+  int64_t slash_pos;
+  char *slash;
+  char data_dir[1024];
   snprintf(buffer, maxlen, "%s/", OUTBASE);
   out = strlen(buffer);
-  if (snapnames) snprintf(buffer+out, maxlen-out, "halos_%s", snapnames[snap]);
+  if (snapnames) {
+    slash = strchr(snapnames[snap], '/');
+    if (slash != NULL) {
+      slash_pos = (int)(slash - snapnames[snap]);
+      strncpy(data_dir, snapnames[snap], slash_pos);
+      data_dir[slash_pos] =  '\0';
+      snprintf(buffer+out, maxlen-out, "halos_%s", data_dir);
+    } else {
+      snprintf(buffer+out, maxlen-out, "halos_%s", snapnames[snap]);
+    }
+  }
   else snprintf(buffer+out, maxlen-out, "halos_%"PRId64, snap);
   out = strlen(buffer);
   snprintf(buffer+out, maxlen-out, ".%"PRId64".%s", chunk, type);
diff --git a/load_balance.c b/load_balance.c
index 4c22ac9..ada0a14 100644
--- a/load_balance.c
+++ b/load_balance.c
@@ -20,7 +20,11 @@ void divide_projection(struct projection *proj, int64_t pieces, float *places)
   assert(pieces > 0);
   for (i=0; i<PROJECTION_SIZE; i++) np += proj->data[i];
   np = (np + pieces - 1)/pieces;  //Round up, if possible
-  places[0] = 0;
+  for (i=0; i<PROJECTION_SIZE&&n<pieces; i++)
+    if (proj->data[i] > 0) {
+      places[0] = BOX_SIZE * ((double)i / (double)PROJECTION_SIZE);
+      break;
+    }
   for (i=0; i<PROJECTION_SIZE&&n<pieces; i++) {
     cp += proj->data[i];
     if (cp > n*np) {
@@ -35,6 +39,12 @@ void divide_projection(struct projection *proj, int64_t pieces, float *places)
     fprintf(stderr, "[Warning] Projection failed; reverting to equal volume divisions.\n");
     for (; n<pieces; n++)
       places[n] = places[n-1] + (BOX_SIZE-places[n-1])/(double)(pieces-n+1);
+  } else {
+    for (i=PROJECTION_SIZE-1; i>places[pieces-1]; i--)
+      if (proj->data[i] > 0) {
+	places[pieces] = BOX_SIZE * ((double)(i+1) / (double)PROJECTION_SIZE);
+	break;
+      }
   }
 } 
 
@@ -191,7 +201,7 @@ void decide_chunks_for_memory_balance() {
     accumulate_projections(pr, proj_start, todo);
     for (i=0; i<todo; i++) {
       divide_projection(pr + proj_start + i, chunks[dir], divisions);
-      divisions[chunks[dir]] = BOX_SIZE;
+      //divisions[chunks[dir]] = BOX_SIZE;
       for (j=0; j<chunks[dir]; j++) {
 	offset = i*chunks[dir]+j;
 	bnds = (dir < 2) ? pr[proj_start+todo+offset].bounds
@@ -209,6 +219,7 @@ void decide_chunks_for_memory_balance() {
     todo *= chunks[dir];
   }
 
+
   free(divisions);
   free(pr);
 }
diff --git a/nfw.c b/nfw.c
index b53301f..08de831 100644
--- a/nfw.c
+++ b/nfw.c
@@ -11,7 +11,7 @@
 #define MIN_PART_PER_BIN 15
 #define MIN_SCALE_PART (100)
 
-inline double c_to_f(double c) {
+extern inline double c_to_f(double c) {
   double cp1 = 1.0+c;
   return (c*cp1 / (log1p(c)*cp1 - c));
 }
diff --git a/potential.c b/potential.c
index 89d05e2..31005ee 100644
--- a/potential.c
+++ b/potential.c
@@ -13,13 +13,13 @@
 #define POTENTIAL_HALT_AFTER_BOUND 0
 #endif /* !def POTENTIAL_HALT_AFTER_BOUND */
 
-inline double _distance2(float *p1, float *p2) {
+extern inline double _distance2(float *p1, float *p2) {
   double dx, r2=0;
   for (int64_t k=0; k<3; k++) { dx=p1[k]-p2[k]; r2+=dx*dx; }
   return (r2);
 }
 
-inline double inv_distance(float *p1, float *p2) {
+extern inline double inv_distance(float *p1, float *p2) {
   double r = sqrt(_distance2(p1,p2));
   if (r < FORCE_RES) r = FORCE_RES;
   return (1.0/r);
diff --git a/scripts/gen_merger_cfg.pl b/scripts/gen_merger_cfg.pl
index 93ca2da..80841bc 100755
--- a/scripts/gen_merger_cfg.pl
+++ b/scripts/gen_merger_cfg.pl
@@ -63,7 +63,7 @@ for my $num ($config->{STARTING_SNAP}..($num_snaps-1)) {
 	last unless (/^#/);
     }
     die "Couldn't extract scale factor from file $outbase/out_$num.list!" unless defined $scale;
-    if ((-s "$outbase/out_$num.list") < 20000) {
+    if ((-s "$outbase/out_$num.list") < 2500) {
 	warn "Skipping $outbase/out_$num.list (too few halos).\n";
     }
     else {
@@ -75,11 +75,12 @@ for my $num ($config->{STARTING_SNAP}..($num_snaps-1)) {
 
 our $box_divisions = int(($size / 2e9)**(1/3));
 $box_divisions = 1 if ($box_divisions < 1);
-our $timesteps = int(@scales / 34);
+our $timesteps = 5;
+#our $timesteps = int(@scales / 34);
 our $sub_timesteps = 2*$timesteps;
 $timesteps = 1 if ($timesteps < 1);
 $sub_timesteps = 1 if ($sub_timesteps < 1);
-our $max_phantoms = $timesteps;
+our $max_phantoms = $timesteps/2;
 our $max_phantoms_small = int($timesteps/2);
 $max_phantoms_small = 1 if ($max_phantoms_small < 1);
 our $mass_res_ok = sprintf("%g", $part_mass*1000);
@@ -121,23 +122,24 @@ MIN_TIMESTEPS_SUB_MMP_TRACKED = $sub_timesteps
 MAX_PHANTOM_FRACTION = 0.25
 
 MAJOR_MERGER=0.3 #The merger ratio which constitutes a major merger
-MIN_MMP_MASS_RATIO=0.3 #The minimum mass for a progenitor to be considered an MMP
+MIN_MMP_MASS_RATIO=0.5 #The minimum mass for a progenitor to be considered an MMP
 MIN_MMP_VMAX_RATIO=0.7 #The minimum vmax for a progenitor to be considered an MMP
 
 PADDING_TIMESTEPS=0 #Don't kill halos if they have link problems during the last 1 timestep.
 
 LAST_DITCH_SEARCH_LIMIT=1.0 #For connecting halos which have "moved" up 
 			    #to this amount times their virial radius
-LAST_DITCH_VMAX_RATIO_1=1.4  # For connecting halos which have "moved"
+LAST_DITCH_VMAX_RATIO_1=1.1  # For connecting halos which have "moved"
 			     # unphysical amounts
 LAST_DITCH_VMAX_RATIO_2=2.5 
 MAX_PHANTOM=$max_phantoms       # max timesteps to keep phantom halo
 MAX_PHANTOM_SMALL=$max_phantoms_small # max timesteps to keep small phantom halo
-SMALL_PARTICLE_LIMIT=49 # Halos smaller than this size get
+SMALL_PARTICLE_LIMIT=99 # Halos smaller than this size get
 			# kept around for less time.
-TIDAL_FORCE_LIMIT=0.4
+TIDAL_FORCE_LIMIT=0.1
 RECURSION_LIMIT=5
-METRIC_LIMIT=7
+METRIC_LIMIT=15
+UNPHYSICAL=46
 METRIC_BREAK_LIMIT=3.2 #Below which we break a link.
 MASS_RES_OK=$mass_res_ok #Halo mass above which there are probably
 		 #not resolution issues.
diff --git a/scripts/rockstar_base.cfg b/scripts/rockstar_base.cfg
new file mode 100644
index 0000000..5c5434b
--- /dev/null
+++ b/scripts/rockstar_base.cfg
@@ -0,0 +1,13 @@
+# Default parameters for Enzo simulation
+# File used by setup_rockstar_enzo.py
+OVERLAP_LENGTH = 0.1
+FILE_FORMAT = ENZO
+OUTPUT_FORMAT = BINARY
+PARALLEL_IO = 1
+OUTBASE = rockstar_halos
+FORK_READERS_FROM_WRITERS = 1
+DELETE_BINARY_OUTPUT_AFTER_FINISHED = 0
+FULL_PARTICLE_CHUNKS = 1
+MIN_HALO_OUTPUT_SIZE = 30
+MASS_DEFINITION = vir
+
diff --git a/scripts/sample-auto-restart.pbs b/scripts/sample-auto-restart.pbs
new file mode 100644
index 0000000..8515e84
--- /dev/null
+++ b/scripts/sample-auto-restart.pbs
@@ -0,0 +1,60 @@
+#!/bin/bash
+#PBS -N rockstar
+#PBS -l nodes=1:ppn=16
+#PBS -l walltime=12:00:00
+#PBS -l pmem=1900mb
+#PBS -q queue
+#PBS -k oe
+#PBS -j oe
+#PBS -m abe
+##PBS -V
+#PBS -M name@email.com
+cd $PBS_O_WORKDIR
+
+module purge
+module add gcc hdf5
+module add openmpi
+module list
+
+output=hosts
+input=$PBS_NODEFILE
+ppn=$PBS_NUM_PPN
+np=$PBS_NP
+nn=$PBS_NUM_NODES
+
+hosts=`cat $input | uniq`
+[ -f hosts ] && rm hosts
+for h in $hosts; do
+    ns=`grep -c $h $input`
+    ns=`expr $ns / $ppn`
+    echo "$h slots=$ns" >> $output
+done
+
+[ ! -d rockstar_halos ] && mkdir rockstar_halos
+[ -f rockstar_halos/auto-rockstar.cfg ] && rm -v rockstar_halos/auto-rockstar.cfg
+if [ -f rockstar_halos/restart.cfg ]; then
+    cfg=rockstar_halos/restart.cfg
+    for i in `seq 0 100`; do
+	newc=`echo $i | gawk '{printf "client%3.3d.out", $1}'`
+	news=`echo $i | gawk '{printf "server%3.3d.out", $1}'`
+	if [ ! -f $newc ]; then
+	    cp -v client.out $newc
+	    cp -v server.out $news
+	    break
+	fi
+    done
+else
+    cfg=rockstar.cfg
+    [ -f client.out ] && rm -v client*.out
+    [ -f server.out ] && rm -v server*.out
+fi
+
+./rockstar-galaxies -c $cfg >& server.out&
+echo "./rockstar-galaxies -c $cfg >& server.out&"
+while [ ! -e rockstar_halos/auto-rockstar.cfg ]; do
+    sleep 1
+done
+mpirun -n $nn --hostfile $output ./rockstar-galaxies -c rockstar_halos/auto-rockstar.cfg >& client.out
+echo "mpirun -n $nn --hostfile $output ./rockstar-galaxies -c rockstar_halos/auto-rockstar.cfg >& client.out"
+
+exit 0
diff --git a/scripts/setup_rockstar_enzo.py b/scripts/setup_rockstar_enzo.py
new file mode 100644
index 0000000..0639771
--- /dev/null
+++ b/scripts/setup_rockstar_enzo.py
@@ -0,0 +1,107 @@
+import glob, os
+import numpy as np
+try:
+    import yt
+except:
+    raise RuntimeError('yt not installed')
+
+restart_snap = None  # filename of the first dataset in the restart
+                     # (None for no restart; True to automatically find the output)
+n_nodes = 1          # Number of compute nodes
+n_procs = 8         # Total number of cores. Must be divisible by 8.
+n_readers = 2        # Number of reader tasks in rockstar
+particle_split = 0   # Number of particle splitting iterations (in Enzo)
+
+# These filenames usually don't need changing
+rockstar_base_cfg = "rockstar_base.cfg"
+rockstar_cfg = "rockstar.cfg"
+outbase = "rockstar_halos"
+
+# Create file with parameter files, sorted by time
+filename = "pfs.dat"
+bases = [["DD", "output_"],
+         ["DD", "data"],
+         ["DD", "DD"],
+         ["RD", "RedshiftOutput"],
+         ["RS", "restart"]]
+all_files = []
+for b in bases:
+    all_files += glob.glob("%s????/%s????" % (b[0], b[1]))
+times = np.zeros(len(all_files))
+scale = np.zeros(len(all_files))
+for i,f in enumerate(all_files):
+    ds = yt.load(f)
+    times[i] = ds.current_time.in_units('code_time')
+    scale[i] = 1.0 / (ds.current_redshift+1)
+isort = np.argsort(times)
+times = times[isort]
+scale = scale[isort]
+files = []
+for i in isort:
+    files.append(all_files[i])
+fp = open(filename, "w")
+for i,f in enumerate(files):
+    #fp.write("%s %15.12f\n" % (f, scale[i]))
+    fp.write("%s\n" % (f))
+fp.close()
+
+if not os.path.exists(outbase):
+    os.mkdir(outbase)
+
+# Search for last analyzed output if restart_snap is True
+if restart_snap == True:
+    last_rfile = None
+    for f in reversed(files):
+        dirname = f.split("/")[0]
+        rfile = "%s/halos_%s.0.bin" % (outbase, dirname)
+        if os.path.exists(rfile):
+            if last_rfile == None:
+                raise RuntimeError("All datasets analyzed.  Not configuring.  "
+                                   "Double-check if you think otherwise.")
+            print ("Starting with the first dataset without a rockstar halo file :: %s" \
+                % (last_rfile))
+            restart_snap = last_rfile
+            break
+        last_rfile = f
+    if last_rfile == None:
+        print ("Cannot find any rockstar halo files.  Configuring to analyze everything.")
+        restart_snap = None
+    
+# Find the number of the restart snapshot
+if restart_snap == None:
+    restart_num = 0
+else:
+    if files.count(restart_snap) == 0:
+        raise RuntimeError("restart snapshot %s not found" % (restart_snap))
+    else:
+        restart_num = files.index(restart_snap)
+
+# Find the finest proper resolution (use the last snapshot only)
+ds = yt.load(files[-1])
+#dx_min = ds.index.get_smallest_dx().in_units("Mpccm/h")
+particle_res = ds.domain_width[0] / ds.parameters['TopGridDimensions'][0] / \
+               ds.parameters['RefineBy']**ds.parameters['MaximumParticleRefinementLevel']
+gas_present = ('enzo', 'Density') in ds.field_list
+
+# Determine whether a zoom-in simulation
+zoom_in = "StaticRefineRegionLevel[0]" in ds.parameters
+
+# Write rockstar config file
+lines = open(rockstar_base_cfg, "r").readlines()
+fp = open(rockstar_cfg, "w")
+for l in lines:
+    if not l.startswith('#'):
+        fp.write(l)
+fp.write("OUTBASE = %s\n" % (outbase))
+fp.write("NUM_BLOCKS = %d\n" % (n_readers))
+fp.write("NUM_WRITERS = %d\n" % (n_procs))
+fp.write("FORK_PROCESSORS_PER_MACHINE = %d\n" % (n_procs/n_nodes))
+fp.write("SNAPSHOT_NAMES = %s\n" % (filename))
+#fp.write("NUM_SNAPS = %d\n" % (len(files)))
+fp.write("STARTING_SNAP = %d\n" % (restart_num))
+fp.write("FORCE_RES = %g\n" % (particle_res.to('Mpccm/h')))
+fp.write("PERIODIC = %d\n" % (not zoom_in))
+fp.write("ENZO_ZOOMIN_RESTRICT = %d\n" % (zoom_in))
+fp.write("ENZO_PARTICLE_SPLITTING = %d\n" % (particle_split))
+fp.write("RESCALE_PARTICLE_MASS = %d\n" % (gas_present))
+fp.close()
