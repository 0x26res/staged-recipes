--- a/src/lib.rs	2022-10-31 04:42:05.000000000 -0500
+++ b/src/lib.rs	2023-10-23 15:00:09.250313296 -0500
@@ -51,13 +51,13 @@
         |actual_len| if actual_len == length {
             Ok(bytes)
         } else {
-            Err(exceptions::ValueError::py_err(format!("Expected bytes of length {}, got {}", length, actual_len)))
+            Err(exceptions::PyValueError::new_err(format!("Expected bytes of length {}, got {}", length, actual_len)))
         })
 }
 
 fn _to_pytuple(any: &PyAny) -> PyResult<&PyTuple> {
     any.downcast::<PyTuple>()
-        .map_err(|_| exceptions::TypeError::py_err("Expected tuple"))
+        .map_err(|_| exceptions::PyTypeError::new_err("Expected tuple"))
 }
 
 // Main interface
@@ -77,7 +77,7 @@
 ///
 /// * `ValueError` - If either the public or private key is invalid.
 #[pyfunction]
-#[text_signature = "(keypair, message)"]
+#[pyo3(text_signature = "(keypair, message)")]
 pub fn sign(keypair: Keypair, message: Message) -> PyResult<Sig> {
     let mut public = [0u8; PUBLIC_KEY_LENGTH];
     let mut private = [0u8; SECRET_KEY_LENGTH];
@@ -85,12 +85,12 @@
     private.clone_from_slice(&keypair.1[0..SECRET_KEY_LENGTH]);
     let secret = match SecretKey::from_bytes(&private) {
         Ok(some_secret) => some_secret,
-        Err(err) => return Err(exceptions::ValueError::py_err(format!("Invalid secret key: {}", err.to_string()))),
+        Err(err) => return Err(exceptions::PyValueError::new_err(format!("Invalid secret key: {}", err.to_string()))),
     };
 
     let public = match PublicKey::from_bytes(&public) {
         Ok(some_public) => some_public,
-        Err(err) => return Err(exceptions::ValueError::py_err(format!("Invalid public key: {}", err.to_string()))),
+        Err(err) => return Err(exceptions::PyValueError::new_err(format!("Invalid public key: {}", err.to_string()))),
     };
 
     let context = signing_context(SIGNING_CTX);
@@ -115,15 +115,15 @@
 ///
 /// * `ValueError` - If either the signature or public key are structurally invalid.
 #[pyfunction]
-#[text_signature = "(signature, message, pubkey)"]
+#[pyo3(text_signature = "(signature, message, pubkey)")]
 pub fn verify(signature: Sig, message: Message, pubkey: PubKey) -> PyResult<bool> {
     let sig = match Signature::from_bytes(&signature.0) {
         Ok(some_sig) => some_sig,
-        Err(err) => return Err(exceptions::ValueError::py_err(format!("Invalid signature: {}", err.to_string()))),
+        Err(err) => return Err(exceptions::PyValueError::new_err(format!("Invalid signature: {}", err.to_string()))),
     };
     let pk = match PublicKey::from_bytes(&pubkey.0) {
         Ok(some_pk) => some_pk,
-        Err(err) => return Err(exceptions::ValueError::py_err(format!("Invalid public key: {}", err.to_string()))),
+        Err(err) => return Err(exceptions::PyValueError::new_err(format!("Invalid public key: {}", err.to_string()))),
     };
     let result = pk.verify_simple(SIGNING_CTX, &message.0, &sig);
     Ok(result.is_ok())
@@ -139,7 +139,7 @@
 ///
 /// A tuple containing the 32-byte public key and 64-byte secret key, in that order.
 #[pyfunction]
-#[text_signature = "(seed)"]
+#[pyo3(text_signature = "(seed)")]
 pub fn pair_from_seed(seed: Seed) -> PyResult<Keypair> {
     let k = MiniSecretKey::from_bytes(&seed.0).expect("32 bytes can always build a key; qed");
     let kp = k.expand_to_keypair(ExpansionMode::Ed25519);
@@ -157,11 +157,11 @@
 ///
 /// A tuple containing the 32-byte public key and 64-byte secret key, in that order.
 #[pyfunction]
-#[text_signature = "(secret_key)"]
+#[pyo3(text_signature = "(secret_key)")]
 pub fn pair_from_ed25519_secret_key(secret_key: PrivKey) -> PyResult<Keypair> {
     let secret = match SecretKey::from_ed25519_bytes(&secret_key.0) {
         Ok(some_secret) => some_secret,
-        Err(err) => return Err(exceptions::ValueError::py_err(format!("Invalid secret key: {}", err.to_string()))),
+        Err(err) => return Err(exceptions::PyValueError::new_err(format!("Invalid secret key: {}", err.to_string()))),
     };
     let pub_key = secret.to_public();
 
@@ -178,11 +178,11 @@
 ///
 /// A 64-byte Ed25519 expanded secret key
 #[pyfunction]
-#[text_signature = "(secret_key)"]
+#[pyo3(text_signature = "(secret_key)")]
 pub fn convert_secret_key_to_ed25519(secret_key: PrivKey) -> PyResult<PrivKey> {
     let secret = match SecretKey::from_bytes(&secret_key.0) {
         Ok(some_secret) => some_secret,
-        Err(err) => return Err(exceptions::ValueError::py_err(format!("Invalid secret key: {}", err.to_string()))),
+        Err(err) => return Err(exceptions::PyValueError::new_err(format!("Invalid secret key: {}", err.to_string()))),
     };
 
     Ok(PrivKey(secret.to_ed25519_bytes()))
@@ -202,11 +202,11 @@
 ///
 /// * `ValueError` - If the provided secret key is invalid.
 #[pyfunction]
-#[text_signature = "(secret_key)"]
+#[pyo3(text_signature = "(secret_key)")]
 pub fn public_from_secret_key(secret_key: PrivKey) -> PyResult<PubKey> {
     let sec_key = match SecretKey::from_bytes(&secret_key.0) {
         Ok(some_key) => some_key,
-        Err(err) => return Err(exceptions::ValueError::py_err(format!("Invalid secret key: {}", err.to_string()))),
+        Err(err) => return Err(exceptions::PyValueError::new_err(format!("Invalid secret key: {}", err.to_string()))),
     };
     let pub_key = sec_key.to_public();
 
@@ -225,11 +225,11 @@
 ///
 /// A new extended public key for the child.
 #[pyfunction]
-#[text_signature = "(extended_pubkey, id)"]
+#[pyo3(text_signature = "(extended_pubkey, id)")]
 pub fn derive_pubkey(extended_pubkey: ExtendedPubKey, id: Message) -> PyResult<ExtendedPubKey> {
     let chain_code = ChainCode(extended_pubkey.0);
     let pubkey = PublicKey::from_bytes(&extended_pubkey.1)
-        .map_err(|err| exceptions::ValueError::py_err(format!("Invalid public key: {}", err.to_string())))?;
+        .map_err(|err| exceptions::PyValueError::new_err(format!("Invalid public key: {}", err.to_string())))?;
     let (new_pubkey, new_chaincode) = pubkey.derived_key_simple(chain_code, &id.0);
 
     Ok(ExtendedPubKey(new_chaincode.0, new_pubkey.to_bytes()))
@@ -250,13 +250,13 @@
 /// deterministically, but the secret key nonce is *RANDOM*, even with
 /// identical input.
 #[pyfunction]
-#[text_signature = "(extended_keypair, id)"]
+#[pyo3(text_signature = "(extended_keypair, id)")]
 pub fn derive_keypair(extended_keypair: ExtendedKeypair, id: Message) -> PyResult<ExtendedKeypair> {
     let chain_code = ChainCode(extended_keypair.0);
     let pubkey = PublicKey::from_bytes(&extended_keypair.1)
-        .map_err(|err| exceptions::ValueError::py_err(format!("Invalid public key: {}", err.to_string())))?;
+        .map_err(|err| exceptions::PyValueError::new_err(format!("Invalid public key: {}", err.to_string())))?;
     let privkey = SecretKey::from_bytes(&extended_keypair.2)
-        .map_err(|err| exceptions::ValueError::py_err(format!("Invalid secret key: {}", err.to_string())))?;
+        .map_err(|err| exceptions::PyValueError::new_err(format!("Invalid secret key: {}", err.to_string())))?;
     let keypair = SchnorrkelKeypair{secret: privkey, public: pubkey};
     let (new_keypair, new_chaincode) = keypair.derived_key_simple(chain_code, &id.0);
 
@@ -282,11 +282,11 @@
 /// deterministically, but the secret key nonce is *RANDOM*, even with
 /// identical input.
 #[pyfunction]
-#[text_signature = "(extended_keypair, id)"]
+#[pyo3(text_signature = "(extended_keypair, id)")]
 pub fn hard_derive_keypair(extended_keypair: ExtendedKeypair, id: Message) -> PyResult<ExtendedKeypair> {
     let chain_code = ChainCode(extended_keypair.0);
     let privkey = SecretKey::from_bytes(&extended_keypair.2)
-        .map_err(|err| exceptions::ValueError::py_err(format!("Invalid secret key: {}", err.to_string())))?;
+        .map_err(|err| exceptions::PyValueError::new_err(format!("Invalid secret key: {}", err.to_string())))?;
 
     let (new_mini, new_chaincode) = privkey.hard_derive_mini_secret_key(Some(chain_code), &id.0);
     let new_keypair = new_mini.expand_to_keypair(ExpansionMode::Ed25519);
@@ -308,9 +308,9 @@
     fn extract(obj: &'a PyAny) -> PyResult<Self> {
         let keypair = obj
             .downcast::<PyTuple>()
-            .map_err(|_| exceptions::TypeError::py_err("Invalid Keypair: expected a tuple"))?;
+            .map_err(|_| exceptions::PyTypeError::new_err("Invalid Keypair: expected a tuple"))?;
         if keypair.len() < 2 {
-            return Err(exceptions::IndexError::py_err(format!("Expected tuple of size 2, got {}", keypair.len())));
+            return Err(exceptions::PyIndexError::new_err(format!("Expected tuple of size 2, got {}", keypair.len())));
         }
 
         // Convert bytes to fixed width arrays
@@ -319,13 +319,13 @@
         public.clone_from_slice(
             &keypair.get_item(0)
                     .downcast::<PyBytes>()
-                    .map_err(|_| exceptions::TypeError::py_err("Invalid PubKey: expected a python Bytes object"))
+                    .map_err(|_| exceptions::PyTypeError::new_err("Invalid PubKey: expected a python Bytes object"))
                     .and_then(|b| _check_pybytes_len(b, PUBLIC_KEY_LENGTH))?
                     .as_bytes()[0..PUBLIC_KEY_LENGTH]);
         private.clone_from_slice(
             &keypair.get_item(1)
                     .downcast::<PyBytes>()
-                    .map_err(|_| exceptions::TypeError::py_err("Invalid SecretKey: Expected a python Bytes object"))
+                    .map_err(|_| exceptions::PyTypeError::new_err("Invalid SecretKey: Expected a python Bytes object"))
                     .and_then(|b| _check_pybytes_len(b, SECRET_KEY_LENGTH))?
                     .as_bytes()[0..SECRET_KEY_LENGTH]);
         let keypair = Keypair(public, private);
@@ -346,7 +346,7 @@
     fn extract(obj: &'a PyAny) -> PyResult<Self> {
         let signature = obj
             .downcast::<PyBytes>()
-            .map_err(|_| exceptions::TypeError::py_err(format!("Expected {} byte signature", SIGNATURE_LENGTH)))
+            .map_err(|_| exceptions::PyTypeError::new_err(format!("Expected {} byte signature", SIGNATURE_LENGTH)))
             .and_then(|b| _check_pybytes_len(b, SIGNATURE_LENGTH))?;
 
         // Convert bytes to fixed width array
@@ -361,10 +361,10 @@
     fn extract(obj: &'a PyAny) -> PyResult<Self> {
         let seed = obj
             .downcast::<PyBytes>()
-            .map_err(|_| PyErr::new::<exceptions::TypeError, _>("Expected a bytestring"))?;
+            .map_err(|_| PyErr::new::<exceptions::PyTypeError, _>("Expected a bytestring"))?;
 
         if seed.as_bytes().len() != MINI_SECRET_KEY_LENGTH {
-            return Err(PyErr::new::<exceptions::IndexError, _>(
+            return Err(PyErr::new::<exceptions::PyIndexError, _>(
                 format!("Expected seed with length: {}", MINI_SECRET_KEY_LENGTH),
             ));
         }
@@ -389,7 +389,7 @@
     fn extract(obj: &'a PyAny) -> PyResult<Self> {
         let pubkey = obj
             .downcast::<PyBytes>()
-            .map_err(|_| exceptions::TypeError::py_err("Invalid PubKey, expected bytes object"))
+            .map_err(|_| exceptions::PyTypeError::new_err("Invalid PubKey, expected bytes object"))
             .and_then(|b| _check_pybytes_len(b, PUBLIC_KEY_LENGTH))?;
 
         // Convert bytes to fixed width array
@@ -412,7 +412,7 @@
     fn extract(obj: &'a PyAny) -> PyResult<Self> {
         let secret = obj
             .downcast::<PyBytes>()
-            .map_err(|_| exceptions::TypeError::py_err(format!("Expected {} byte secret key", SECRET_KEY_LENGTH)))
+            .map_err(|_| exceptions::PyTypeError::new_err(format!("Expected {} byte secret key", SECRET_KEY_LENGTH)))
             .and_then(|b| _check_pybytes_len(b, SECRET_KEY_LENGTH))?;
 
         // Convert bytes to fixed width array
@@ -427,7 +427,7 @@
     fn extract(obj: &PyAny) -> PyResult<Self> {
         let messsge = obj
             .downcast::<PyBytes>()
-            .map_err(|_| exceptions::TypeError::py_err("Expected bytes object"))?;
+            .map_err(|_| exceptions::PyTypeError::new_err("Expected bytes object"))?;
         Ok(Message(messsge.as_bytes().to_owned()))
     }
 }
@@ -449,7 +449,7 @@
         // Don't check that the length matches exactly here so that an extended
         // private key can be passed in as well.
         if extended.len() < 2 {
-            return Err(exceptions::IndexError::py_err(format!("Expected tuple of size 2, got {}", extended.len())));
+            return Err(exceptions::PyIndexError::new_err(format!("Expected tuple of size 2, got {}", extended.len())));
         }
 
         // Convert bytes to fixed width arrays
@@ -458,13 +458,13 @@
         chain_code.clone_from_slice(
             &extended.get_item(0)
                     .downcast::<PyBytes>()
-                    .map_err(|_| exceptions::TypeError::py_err("Expected bytes object at index 0"))
+                    .map_err(|_| exceptions::PyTypeError::new_err("Expected bytes object at index 0"))
                     .and_then(|b| _check_pybytes_len(b, CHAIN_CODE_LENGTH))?
                     .as_bytes()[0..CHAIN_CODE_LENGTH]);
         public.clone_from_slice(
             &extended.get_item(1)
                     .downcast::<PyBytes>()
-                    .map_err(|_| exceptions::TypeError::py_err("Expected bytes object at index 1"))
+                    .map_err(|_| exceptions::PyTypeError::new_err("Expected bytes object at index 1"))
                     .and_then(|b| _check_pybytes_len(b, PUBLIC_KEY_LENGTH))?
                     .as_bytes()[0..PUBLIC_KEY_LENGTH]);
         let extended_pubkey = ExtendedPubKey(chain_code, public);
@@ -488,7 +488,7 @@
     fn extract(obj: &'a PyAny) -> PyResult<Self> {
         let extended = _to_pytuple(obj)?;
         if extended.len() < 3 {
-            return Err(exceptions::IndexError::py_err(format!("Expected tuple of size 3, got {}", extended.len())));
+            return Err(exceptions::PyIndexError::new_err(format!("Expected tuple of size 3, got {}", extended.len())));
         }
 
         // Convert bytes to fixed width arrays
@@ -499,19 +499,19 @@
         chain_code.clone_from_slice(
             &extended.get_item(0)
                     .downcast::<PyBytes>()
-                    .map_err(|_| exceptions::TypeError::py_err("Expected bytes object at index 0"))
+                    .map_err(|_| exceptions::PyTypeError::new_err("Expected bytes object at index 0"))
                     .and_then(|b| _check_pybytes_len(b, CHAIN_CODE_LENGTH))?
                     .as_bytes()[0..CHAIN_CODE_LENGTH]);
         public.clone_from_slice(
             &extended.get_item(1)
                     .downcast::<PyBytes>()
-                    .map_err(|_| exceptions::TypeError::py_err("Expected bytes object at index 1"))
+                    .map_err(|_| exceptions::PyTypeError::new_err("Expected bytes object at index 1"))
                     .and_then(|b| _check_pybytes_len(b, PUBLIC_KEY_LENGTH))?
                     .as_bytes()[0..PUBLIC_KEY_LENGTH]);
         private.clone_from_slice(
            &extended.get_item(2)
                     .downcast::<PyBytes>()
-                    .map_err(|_| exceptions::TypeError::py_err("Expected bytes object at index 2"))
+                    .map_err(|_| exceptions::PyTypeError::new_err("Expected bytes object at index 2"))
                     .and_then(|b| _check_pybytes_len(b, SECRET_KEY_LENGTH))?
                     .as_bytes()[0..SECRET_KEY_LENGTH]);
         let extended_keypair = ExtendedKeypair(chain_code, public, private);
