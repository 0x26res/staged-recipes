From 57ca5f746c560842812c780e0a652e1627bee715 Mon Sep 17 00:00:00 2001
From: "Lori A. Burns" <lori.burns@gmail.com>
Date: Wed, 24 May 2023 03:47:21 -0400
Subject: [PATCH 2/5] add IO management, form library as well as executable

---
 src/atom_grids.f90 |  53 ++++++++-------
 src/dma.f90        | 114 +++++++++++++++++++------------
 src/exe.f90        | 163 +++++++++++++++++++++++++++++++++++++++++++++
 src/gdma.f90       | 161 ++++++++++++++++++++++++++++++++------------
 src/input.F90      |   6 +-
 5 files changed, 386 insertions(+), 111 deletions(-)
 create mode 100644 src/exe.f90

diff --git a/src/atom_grids.f90 b/src/atom_grids.f90
index f6f39f2..6cf7211 100644
--- a/src/atom_grids.f90
+++ b/src/atom_grids.f90
@@ -63,6 +63,7 @@ INTEGER, SAVE :: n_r=80, n_a=590, k_mu=3, m_r=2
 !  Bragg-Slater radii from Slater, JCP (1964) 41, 3199. Inert gases
 !  added with same radius as preceding halogen. Hydrogen radius is
 !  twice the Slater value. These values are in Angstrom.
+INTEGER :: outfile
 REAL(dp) :: slater_radius(0:54) = (/ 0.65d0, 0.50d0, 0.50d0,           &
     1.45d0, 1.05d0, 0.85d0, 0.70d0, 0.65d0, 0.60d0, 0.50d0, 0.50d0,    &
     1.80d0, 1.50d0, 1.25d0, 1.10d0, 1.00d0, 1.00d0, 1.00d0, 1.00d0,    &
@@ -224,7 +225,7 @@ INTEGER :: sleg(16)=(/0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120/)
 
 CONTAINS
 
-SUBROUTINE make_grid(ns, zs, c, radius)
+SUBROUTINE make_grid(ns, zs, c, radius, of)
 IMPLICIT NONE
 
 !  ns is the number of DMA sites. c(:,k) specifies the position of site
@@ -233,22 +234,24 @@ IMPLICIT NONE
 !  true, in which case it controls the Becke partitioning of space between
 !  sites. The atomic number controls the scale of the radial grid.
 
-INTEGER, INTENT(IN) :: ns, zs(:)
+INTEGER, INTENT(IN) :: ns, zs(:), of
 REAL(dp), INTENT(IN) :: c(:,:), radius(:)
 
 INTEGER :: a, b, g, i, m, ma, mb, n, p, q, ok
 REAL(dp), ALLOCATABLE :: rr(:,:), aa(:,:), s(:,:), pp(:)
 REAL(dp) :: chi, u, mu_ab, nu_ab, weight, f
 
+outfile = of
+
 !  Arrays used for Becke weighting
 allocate (gr(ns), rr(ns,ns), aa(ns,ns), s(ns,ns), pp(ns), stat=ok)
 if (ok > 0) then
-  print "(a)", "Make_grid: Allocation failed"
+  write(outfile, "(a)") "Make_grid: Allocation failed"
   stop
 else
-  ! print "(a)", "Make_grid: Allocation done"
+  ! write(outfile, "(a)") "Make_grid: Allocation done"
 end if
-print "(a,i0,a)", "Using ", n_r, "-point Euler-MacLaurin radial quadrature"
+write(outfile, "(a,i0,a)") "Using ", n_r, "-point Euler-MacLaurin radial quadrature"
 
 !  Angular grid
 call angular_grid(n_a)
@@ -259,10 +262,10 @@ if (allocated(grid)) then
 end if
 allocate(grid(4,ng),stat=ok)
 if (ok>0) then
-  print "(a,i0,a)", "Main grid allocation failed: ", 32*ng, " bytes needed"
+  write(outfile, "(a,i0,a)") "Main grid allocation failed: ", 32*ng, " bytes needed"
   stop
 else
-  ! print "(a,i0,a)", "Main grid allocation done: ", ng, " points"
+  ! write(outfile, "(a,i0,a)") "Main grid allocation done: ", ng, " points"
 end if
 
 !  Construct grids around each atom
@@ -285,7 +288,7 @@ do n=1,ns
 end do
 start(ns+1)=g+1
 if (g>ng) then
-  print "(a,i0,a)", "Not enough grid points allocated -- ", g, " needed"
+  write(outfile, "(a,i0,a)") "Not enough grid points allocated -- ", g, " needed"
   stop
 end if
 ng=g
@@ -294,12 +297,12 @@ if (ns > 1) then
   !  Assign weight to each point according to Becke formula.
   !  rr(m,n) is the distance between nuclei m and n.
 !  if (Slater) then
-!    print "(a)", "Using specified atom radii for Becke weighting"
+!    write(outfile, "(a)") "Using specified atom radii for Becke weighting"
 !    do a=1,ns
 !      atom_radius(a)=radius(a)
 !    end do
 !  else
-!    print "(a)", "Using equal atom radii for Becke weighting"
+!    write(outfile, "(a)") "Using equal atom radii for Becke weighting"
 !    atom_radius(1:ns)=1d0
 !  end if
   do a=1,ns
@@ -314,7 +317,7 @@ if (ns > 1) then
     end do
   end do
 
-  print "(a,i0)", "Becke smoothing parameter = ", k_mu
+  write(outfile, "(a,i0)") "Becke smoothing parameter = ", k_mu
   a=0
   do g=1,ng
     if (g .ge. start(a+1)) a=a+1
@@ -342,8 +345,8 @@ if (ns > 1) then
     grid(4,g)=grid(4,g)*weight
     if (debug) then
       if (grid(1,g)**2+grid(2,g)**2<1d-6) then
-        print "(i1, 3f12.5, 2f16.5)", a, grid(:,g), weight
-        print "(3f20.8)", (s(i,:), i=1,ns), pp
+        write(outfile, "(i1, 3f12.5, 2f16.5)") a, grid(:,g), weight
+        write(outfile, "(3f20.8)") (s(i,:), i=1,ns), pp
       end if
     end if
   end do
@@ -378,18 +381,18 @@ REAL(dp) :: f
 if (.not. allocated(w_r)) then
   allocate (w_r(n_r), r(n_r), stat=ok)
   if (ok>0) then
-    print "(a)", "Radial_grid: allocation failed"
+    write(outfile, "(a)") "Radial_grid: allocation failed"
   else
-    ! print "(a)", "Radial_grid: allocation done"
+    ! write(outfile, "(a)") "Radial_grid: allocation done"
   end if
 end if
 
 f=m_r*n_r*alpha**3
-! print "(a, i0)", "Radial points for atom ", n
+! write(outfile, "(a, i0)") "Radial points for atom ", n
 do i=1,n_r-1
   r(i)=alpha*(real(i,dp)/real(n_r-i,dp))**m_r
   w_r(i)=f*real(i,dp)**(3*m_r-1)/(real(n_r-i,dp)**(3*m_r+1))
-  ! print "(f12.7,e16.7)", r(i), w_r(i)
+  ! write(outfile, "(f12.7,e16.7)") r(i), w_r(i)
 end do
 
 END SUBROUTINE radial_grid
@@ -399,7 +402,7 @@ SUBROUTINE test_angular_grid(n)
 INTEGER :: n !, i
 
 call Lbdv(n)
-! print "(4f20.16)", (x(i), y(i), z(i), w(i), i=1,n)
+! write(outfile, "(4f20.16)") (x(i), y(i), z(i), w(i), i=1,n)
 
 END SUBROUTINE test_angular_grid
 
@@ -409,7 +412,7 @@ INTEGER :: n
 
 if (Lebedev) then
   call Lbdv(n)
-  print "(a,i0,a)", "Using ", n, "-point Lebedev quadrature"
+  write(outfile, "(a,i0,a)") "Using ", n, "-point Lebedev quadrature"
 else
   call gauss(n)
 end if
@@ -431,17 +434,17 @@ n=2*m*m
 
 k=sleg(m)
 if (k .eq. 0) then
-  print "(a,i0,a)", "No points or weights for ",                       &
+  write(outfile, "(a,i0,a)") "No points or weights for ",                       &
       m, "-point Gauss-Legendre quadrature"
   stop
 else
-  print "(a,i0,a)", "Using ", m, "-point Gauss-Legendre quadrature in theta"
-  print "(a,i0,a)", "and ", 2*m, "-point uniform quadrature in phi"
+  write(outfile, "(a,i0,a)") "Using ", m, "-point Gauss-Legendre quadrature in theta"
+  write(outfile, "(a,i0,a)") "and ", 2*m, "-point uniform quadrature in phi"
 end if
 
 allocate (x(n), y(n), z(n), w(n), stat=ok)
 if (ok>0) then
-  print "(a)", "Allocation failed"
+  write(outfile, "(a)") "Allocation failed"
   stop
 end if
 
@@ -550,7 +553,7 @@ end if
 ! end select
 allocate (x(n), y(n), z(n), w(n), stat=ok)
 if (ok>0) then
-  print "(a)", "Allocation failed"
+  write(outfile, "(a)") "Allocation failed"
   stop
 end if
 select case(n)
@@ -692,7 +695,7 @@ REAL(dp) :: c
 !       goto (1,2,3,4,5,6) code
 select case(code)
 case default
-  print "(a,i0)", 'Gen_Oh: Invalid Code ', code
+  write(outfile, "(a,i0)") 'Gen_Oh: Invalid Code ', code
   stop
 case(1)
   a=1.0d0
diff --git a/src/dma.f90 b/src/dma.f90
index e55f55c..962e8fa 100644
--- a/src/dma.f90
+++ b/src/dma.f90
@@ -20,6 +20,7 @@ MODULE DMA
 !  Fifth Floor, Boston, MA 02110-1301, USA.
 
 
+use iso_c_binding
 USE atom_grids, ONLY : grid, ng, make_grid, Lebedev,                   &
     n_a, n_r, k_mu, start
 IMPLICIT NONE
@@ -75,11 +76,11 @@ DATA IZ(36:56) /0,0,5,0,1,0,1,4,4,0,2,0,2,3,3,1,1,3,1,2,2/
 INTEGER, ALLOCATABLE :: limit(:)
 REAL(dp), ALLOCATABLE :: xs(:,:), radius(:), q(:,:)
 REAL(dp) :: rt(0:20), binom(0:20,0:20), rtbinom(0:20,0:20),         &
-    d(56,56)
+    d(56,56), qt(0:121)
 
 LOGICAL:: slice, linear, planar, general
 INTEGER :: ns, lmax, perp, mindc, maxdc
-REAL(dp) :: tol
+REAL(dp) :: tol, spread
 
 !  Charge density at grid points
 REAL(dp), ALLOCATABLE :: rho(:)
@@ -325,10 +326,29 @@ DATA W(191:210) /                                          &
     4.39934099227335D-10, 2.22939364553444D-13/
 
 CONTAINS
-
+!-------------------------------------------------------------
+! Some getter functions to access the DMA information from C
+INTEGER(C_INT) FUNCTION get_nsites() BIND(c, name='get_nsites')
+    get_nsites = ns
+END FUNCTION get_nsites
+
+INTEGER(C_INT) FUNCTION get_order(site) BIND(c, name='get_order')
+    INTEGER(C_INT), VALUE, INTENT(IN) :: site
+    get_order = limit(site)
+END FUNCTION get_order
+
+REAL(C_DOUBLE) FUNCTION get_dma_value(site, addr) BIND(c, name='get_dma_value')
+    INTEGER(C_INT), VALUE, INTENT(IN) :: site, addr
+    get_dma_value = q(addr,site)
+END FUNCTION get_dma_value
+
+REAL(C_DOUBLE) FUNCTION get_tot_value(addr) BIND(c, name='get_tot_value')
+    INTEGER(C_INT), VALUE, INTENT(IN) :: addr
+    get_tot_value = qt(addr)
+END FUNCTION get_tot_value
 !-----------------------------------------------------------------   DMA
 
-SUBROUTINE dma_main(w,kp)
+SUBROUTINE dma_main(w,kp,infile,outfile)
 USE input
 IMPLICIT NONE
 !-----------------------------------------------------
@@ -337,7 +357,7 @@ IMPLICIT NONE
 !     Version for Cadpac5 , R D Amos, June 1990
 !-----------------------------------------------------
 REAL(dp) :: w(*)
-INTEGER :: kp, prank=5
+INTEGER :: kp, prank=5, infile, outfile
 
 !                      Distributed Multipole Analysis
 
@@ -365,9 +385,9 @@ CHARACTER(LEN=16) :: wa, wb, wc
 
 LOGICAL :: check
 
-INTEGER :: kr=0, nerror=0, itol, zs(MAXS)
+INTEGER :: iw=6, kr=0, kw=0, nerror=0, itol, zs(MAXS)
 INTEGER :: i, j, k, l, m, ok
-REAL(dp) :: r, ox=0d0, oy=0d0, oz=0d0, qt(0:121)
+REAL(dp) :: r, ox=0d0, oy=0d0, oz=0d0!, qt(0:121)
 
 !  Directive syntax:
 !   MULTIPOLES
@@ -464,7 +484,9 @@ REAL(dp) :: r, ox=0d0, oy=0d0, oz=0d0, qt(0:121)
 !          linear molecules this procedure is always used.
 
 lmax=20
+iw=outfile
 kr=0
+kw=0
 linear=.false.
 planar=.false.
 general=.false.
@@ -472,6 +494,7 @@ perp=0
 itol=18
 nuclei=.true.
 slice=.false.
+spread=1.0d0
 bigexp=bigexp_default
 lebedev=.true.
 nerror=0
@@ -495,10 +518,10 @@ call atom_sites
 !  Read input keywords
 do
   if (nerror .eq. 1) then
-    print '(a)', 'Syntax checking only from this point.'
+    write(outfile, '(a)') 'Syntax checking only from this point.'
     nerror=nerror+1
   endif
-  call read_line(eof)
+  call read_line(eof, infile)
   call readu(wa)
   select case(wa)
   case('ATOMS')  !  Default choice of sites
@@ -508,7 +531,7 @@ do
   case('START')
     exit
   case('LINEAR')
-    PRINT '(/A)', 'The LINEAR option is no longer needed'
+    write(outfile, '(/A)') 'The LINEAR option is no longer needed'
   case('PLANAR')
     call readu(wb)
     select case(wb)
@@ -540,6 +563,10 @@ do
     planar=.false.
     perp=0
 
+  case('SPREAD')
+    call readf(spread,rfact)
+    if (spread .eq. 0.0d0) spread=1.0d0
+
   case("GRID")
     do while (item < nitems)
       call readu(wa)
@@ -760,13 +787,13 @@ do
   case("BIGEXP","SWITCH")
     call readf(bigexp)
     if (bigexp < 0d0) then
-      print "(a)", "Switch value must not be negative"
+      write(outfile, "(a)") "Switch value must not be negative"
       nerror=nerror+1
     end if
     if (bigexp > 0d0) general=.true.
 
   case default
-    print '(a,a)', 'Unrecognised DMA keyword ', wa
+    write(outfile, '(a,a)') 'Unrecognised DMA keyword ', wa
     nerror=nerror+1
   end select
 end do
@@ -809,20 +836,20 @@ write (iw,"(/25x,a/)") "Distributed Multipole Analysis"
 Q=0.0d0
 
 if (bigexp > 0d0) then
-  print "(a,a,f0.5)", "Standard DMA for products of primitives",  &
+  write(outfile, "(a,a,f0.5)") "Standard DMA for products of primitives",  &
       " with exponent greater than ", bigexp
   general=.true.
-  call make_grid(ns, zs, xs, radius)
+  call make_grid(ns, zs, xs, radius, outfile)
   if (allocated(rho)) then
     deallocate(rho)
   end if
   allocate(rho(ng), stat=ok)
   if (ok>0) then
-    print "(a)", "Allocation of density grid failed"
+    write(outfile, "(a)") "Allocation of density grid failed"
     stop
   end if
 else
-  print "(a)", "Standard DMA"
+  write(outfile, "(a)") "Standard DMA"
 end if
 
 if (general) then
@@ -832,18 +859,20 @@ if (general) then
   perp=0
 end if
 
-print "(/2a)", "Positions and radii in ", trim(runit)
+write(outfile, "(/2a)") "Positions and radii in ", trim(runit)
 
 if (Qfactor(0) .ne. 1d0) then
-  print "(/a)", "Multipole moments are in SI units, multiplied by 10^(10k+20) for rank k"
+  write(outfile, "(/a)") "Multipole moments are in SI units, multiplied by 10^(10k+20) for rank k"
 else
-  print "(a)", "Multipole moments in atomic units, ea_0^k for rank k"
+  write(outfile, "(a)") "Multipole moments in atomic units, ea_0^k for rank k"
 end if
 
 if (linear) then
-  call dmaql0(w,kr)
+  !call dmaql0(w,kr)
+  call dmaql0(w,kw)
 else
-  call dmaqlm(w,kr)
+  !call dmaqlm(w,kr)
+  call dmaqlm(w,kw)
 endif
 
 qt=0.0d0
@@ -929,7 +958,7 @@ END SUBROUTINE dma_main
 
 !---------------------------------------------------------------  DMAQL0
 
-SUBROUTINE dmaql0(densty,kr)
+SUBROUTINE dmaql0(densty,iw)
 IMPLICIT NONE
 !-----------------------------------------------------
 !     Copyright A J Stone University of Cambridge 1983
@@ -937,7 +966,7 @@ IMPLICIT NONE
 !     Version for Cadpac5 , R D Amos, June 1990
 !-----------------------------------------------------
 REAL(dp), INTENT(IN) :: densty(*)
-INTEGER, INTENT(IN) :: kr
+INTEGER, INTENT(IN) :: iw
 
 
 !  Calculate multipole moments, and shift them to the nearest site. In
@@ -1013,7 +1042,8 @@ do i=1,nat
   zi=c(3,i)
   if (nuclei .and. i .ge. mindc .and. i .le. maxdc) then
     qt(0)=zan(i)
-    call movez(qt, zi, kr)
+    !call movez(qt, zi, kr)
+    call movez(qt, zi, iw)
   endif
   !  Find shells for atom i
   ii1=0
@@ -1150,7 +1180,7 @@ do i=1,nat
             zp=zi-p*zji
             za=zi-zp
             zb=zj-zp
-            if (iand(kr,2) .ne. 0) write (iw,"(3(i5,i4), f11.4)")              &
+            if (iw .gt. 0) write (iw,"(3(i5,i4), f11.4)")              &
                 i,j, ii,jj, ig,jg, zp
 !  Use numerical integration to evaluate the multipole integrals
 !  over x and y (they are the same).
@@ -1215,7 +1245,7 @@ do i=1,nat
 !  End of loop over basis functions
                   end do
                 end do
-                if (iand(kr,1) .ne. 0) write (iw,"(a,i3, 11f11.7)")            &
+                if (iw .gt. 0) write (iw,"(a,i3, 11f11.7)")            &
                     "slice", is, (qt(iq), iq=0,min(lmax,10))
 !  Move multipoles to expansion site contained in this slice.
 !  Note that they are currently referred to the overlap centre P.
@@ -1275,22 +1305,22 @@ do i=1,nat
                   if (mod(mx,2) .eq. 0 .and. mod(my,2) .eq. 0)         &
                       call addql0 (qt, min(nq,lmax), -fac*ci*cj*d(ia,jb), &
                       gx(mx),gx(my),gz(0,iz(ia),iz(jb)))
-                  if (iand(kr,2) .ne. 0) write (iw,"(1p,3e10.2,2i3,1p,4e10.2)") &
+                  if (iw .gt. 0) write (iw,"(1p,3e10.2,2i3,1p,4e10.2)") &
                       fac, ci, cj, ia, jb, d(ia,jb),                   &
                       gx(mx), gx(my), gz(0,iz(ia),iz(jb))
 !  End of loop over basis functions
                 end do
               end do
-              if (iand(kr,1) .ne. 0) write (iw,"(3(i5,i4), f11.4, 3x, 11f12.8)") &
+              if (iw .gt. 0) write (iw,"(3(i5,i4), f11.4, 3x, 11f12.8)") &
                   i,j, ii,jj, ig,jg, zp, (qt(iq), iq=0,10)
 !  Move multipoles to nearest site.
-              call movez(qt, zp, kr)
+              call movez(qt, zp, iw)
             endif
 !  End of loop over primitives
           end do
         end do
-        if (iand(kr,1) .ne. 0) write (iw,"(/(5f15.8))") (q(0:4,ia), ia=1,ns)
-        if (iand(kr,1) .ne. 0) write (iw,"(1x)")
+        if (iw .gt. 0) write (iw,"(/(5f15.8))") (q(0:4,ia), ia=1,ns)
+        if (iw .gt. 0) write (iw,"(1x)")
 !  End of loop over shells
       end do
     end do
@@ -1428,7 +1458,7 @@ END SUBROUTINE shiftz
 
 !----------------------------------------------------------------- MOVEZ
 
-SUBROUTINE movez (qp, p, kr)
+SUBROUTINE movez (qp, p, iw)
 IMPLICIT NONE
 !-----------------------------------------------------
 !     Copyright A J Stone University of Cambridge 1983
@@ -1439,7 +1469,7 @@ IMPLICIT NONE
 !  to the nearest site.
 REAL(dp), INTENT(INOUT) :: qp(0:)
 REAL(dp), INTENT(IN) :: p
-INTEGER, INTENT(IN) :: kr
+INTEGER, INTENT(IN) :: iw
 
 REAL(dp) :: r(maxs)
 REAL(dp), PARAMETER :: eps=1d-8
@@ -1467,7 +1497,7 @@ do
     m(2)=i
   end do
 !  Multipoles of ranks LOW to LIMIT(K) are to be moved at this stage
-  if (iand(kr,2) .ne. 0) write (6,1001) p, low, limit(k),                   &
+  if (IW .gt. 0) write (6,1001) p, low, limit(k),                   &
       (m(i), xs(3,m(i)), i=1,n)
 1001  format (' From', F7.3, ': ranks', I3, ' to', I3,                  &
           ' to be moved to site ', I1, ' at', F7.3:                     &
@@ -1620,10 +1650,10 @@ END SUBROUTINE dmaerf
 
 !-----------------------------------------------------------------DMAQLM
 
-SUBROUTINE dmaqlm(densty,kr)
+SUBROUTINE dmaqlm(densty,iw)
 IMPLICIT NONE
 REAL(dp), INTENT(IN) :: densty(*)
-INTEGER, INTENT(IN) :: kr
+INTEGER, INTENT(IN) :: iw
 
 !-----------------------------------------------------
 !     Copyright A J Stone University of Cambridge 1983
@@ -1691,7 +1721,7 @@ REAL(dp) :: aa, ai, arri, aj, ci, cj, ch, dum, e, fac, f, g,           &
 
 do_quadrature=.false.
 
-if (iand(kr,1) .ne. 0) print "(a/a)",                                           &
+if (iw .gt. 0) write(iw, "(a/a)")                                      &
     '    Atoms   Shells Primitives            Position',               &
     '     Multipole contributions ...'
 katom(nshell+1)=0
@@ -1782,7 +1812,7 @@ do i=1,nat
           end if
         end do
 
-        if (iand(kr,8) .ne. 0 .and. la == 5) then
+        if (iw .gt. 0 .and. la == 5) then
           !  Print out temporary density matrix
           print "(4i4)", i, j, la, lb
           do mi = mini,maxi
@@ -1872,7 +1902,7 @@ do i=1,nat
               yp=yi-ya
               zp=zi-za
               t=sqrt(1.0d0/aa)
-              if (iand(kr,2) .ne. 0) print ("(3(i5,i4), 3x, 3f10.5)"),      &
+              if (iw .gt. 0) write(iw, "(3(i5,i4), 3x, 3f10.5)")      &
                   i,j, ii,jj, ig,jg, xp,yp,zp
 !  LQ is the maximum rank of multipole to which these functions
 !  contribute. The integrals involve polynomials up to order 2LQ,
@@ -1947,7 +1977,7 @@ do i=1,nat
                 end do
               end do
 
-              if (iand(kr,1) .ne. 0) print "(f10.6: / 3f10.6: / 5f10.6: / 7f10.6: / 9f10.6: /&
+              if (iw .gt. 0) print "(f10.6: / 3f10.6: / 5f10.6: / 7f10.6: / 9f10.6: /&
                   & 11f10.6: / 13f10.6: / 15f10.6: / 17f10.6: / 19f10.6: / 21f10.6)", &
                   qt(1:(nq+1)**2)
 !  Move multipoles to expansion centre nearest to overlap centre P.
@@ -1967,7 +1997,7 @@ do i=1,nat
               xp=xi-p*xji
               yp=yi-p*yji
               zp=zi-p*zji
-              if (iand(kr,2) .ne. 0) print "(2i5, 3f20.15)", ig, jg, xp, yp, zp
+              if (iw > 0) write(iw, "(2i5, 3f20.15)") ig, jg, xp, yp, zp
               do k=1,ng
                 xk=grid(1,k)
                 yk=grid(2,k)
@@ -2889,7 +2919,7 @@ REAL(dp) :: a2kp1, rr, rfx, rfy, rfz, s
 
 l=iabs(j)
 if ((l+1)**2 .gt. max) then
-  print '(a,i3)', 'Insufficient array space for harmonics up to rank',L
+  write(6,'(a,i3)') 'Insufficient array space for harmonics up to rank',L
   call die('Consult authors')
 endif
 rr=x**2+y**2+z**2
diff --git a/src/exe.f90 b/src/exe.f90
new file mode 100644
index 0000000..ab74356
--- /dev/null
+++ b/src/exe.f90
@@ -0,0 +1,163 @@
+program gdma
+
+USE input
+USE version
+USE dma
+USE atom_grids, ONLY: debug_grid => debug
+USE timing, ONLY: start_timer, timer, time_and_date
+use libgdma
+!IMPLICIT NONE
+!
+!INTEGER, PARAMETER :: dp=kind(1d0)
+!
+!CHARACTER(LEN=100) :: file
+!CHARACTER(LEN=80) :: buffer
+!CHARACTER(LEN=20) :: key
+!CHARACTER(LEN=8) :: whichd="SCF"
+!CHARACTER(LEN=24) :: datestring
+!
+!!  Maximum number of sites is number of atoms + nextra
+!INTEGER :: nextra=16
+!INTEGER :: ncoorb, maxl, cmax, nprim, nx, num, ich, mul
+!INTEGER, ALLOCATABLE :: shell_type(:)
+!INTEGER :: i, j, k, kp=0
+!LOGICAL :: eof, fchk, first, ok=.false.
+!
+!REAL(dp), ALLOCATABLE :: densty(:,:), dtri(:)
+!INTEGER :: ir=5 ! Input stream
+!
+!LOGICAL :: verbose=.false., debug(0:2)=.false.
+
+
+print "(15x,a/15x,a//15x,a//15x,5a/14x,4a)",                           &
+    "                      G D M A",                                   &
+    "                  by Anthony Stone",                              &
+    "Distributed Multipoles from Gaussian wavefunctions",              &
+    "              version ", gdma_version, " (", commit, ")",         &
+    "Compiled with ", compiler, " on ", compiled
+call time_and_date(datestring)
+print "(/2A)", "Starting at ", datestring
+
+call start_timer
+
+punchfile="dma.punch"
+nat=0
+fchk=.false.
+first=.true.
+do
+  call read_line(eof)
+  if (eof) exit
+  call readu(key)
+  select case(key)
+  case("","NOTE","!")
+    cycle
+  case("VERBOSE")
+    verbose=.true.
+  case("QUIET")
+    debug=.false.
+    verbose=.false.
+  case("DEBUG")
+    debug(0)=.true.
+    do while (item<nitems)
+      call readi(k)
+      if (k>0) then
+        debug(k)=.true.
+      else
+        debug(-k)=.false.
+      end if
+    end do
+    debug_grid=.true.
+    verbose=.true.
+  case("ANGSTROM")
+    rfact=bohr
+  case("BOHR")
+    rfact=1d0
+  case("SI")
+    Qfactor(0)=echarge
+    do k=1,20
+      Qfactor(k)=Qfactor(k-1)*bohr
+    end do
+  case("AU")
+    Qfactor=1d0
+  case("COMMENT","TITLE")
+    call reada(buffer)
+    print "(/a/)", trim(buffer)
+  case("DENSITY")
+    if (fchk) call die                                         &
+        ("Specify density to use before reading data file",.true.)
+    call readu(whichd)
+  case("FILE","READ")
+    nat=0
+    fchk=.false.
+    ok=.false.
+    first=.true.
+    if (allocated(dtri)) deallocate(dtri)
+    do while (item<nitems)
+      call readu(key)
+      select case(key)
+      case("DENSITY")
+        call readu(whichd)
+      case default
+        call reread(-1)
+        call reada(file)
+        open(unit=9,file=file,status="old",iostat=k)
+        if (k .ne. 0) then
+          call die("Can't open file "//file,.true.)
+        endif
+      end select
+    end do
+    ir=9
+    call get_data(whichd,ok,5)
+    close(9)
+    ir=5
+    fchk=.true.
+  case ("HERE")
+    call get_data(whichd,ok,5)
+    fchk=.true.
+  case("NAMES")
+    if (.not. fchk) call die                                   &
+        ("Read data file before specifying atom names",.false.)
+    call read_line(eof)
+    do i=1,nat
+      call geta(name(i))
+    end do
+  case("GO","START","MULTIPOLES")
+    if (.not. ok) then
+      call die (trim(whichd)//" density not found",.false.)
+    endif
+    if (first) then
+      ! convert density matrix to triangular form
+      allocate(dtri(nx))
+      k=0
+      do i=1,num
+        do j=1,i
+          k=k+1
+          dtri(k)=densty(i,j)
+        end do
+      end do
+      deallocate(densty)
+      first=.false.
+    endif
+    print "(//2A/)", "Using "//trim(whichd)//" density matrix",  &
+        " from file "//trim(file)
+    call dma_main(dtri,kp,5,6)
+    call timer
+  case("RESET")
+    nat=0
+    fchk=.false.
+    ok=.false.
+    first=.true.
+    deallocate(dtri)
+    whichd="SCF"
+  case("FINISH")
+    exit
+  case default
+    call die("Keyword "//trim(key)//" not recognized",.true.)
+  end select
+end do
+
+call time_and_date(datestring)
+print "(/2A)", "Finished at ", datestring
+
+END program gdma
+
diff --git a/src/gdma.f90 b/src/gdma.f90
index ae1d545..4c1dc67 100644
--- a/src/gdma.f90
+++ b/src/gdma.f90
@@ -1,4 +1,5 @@
-PROGRAM gdma
+module libgdma
+!program gdma
 
 !  Distributed Multipole Analysis for Gaussian Wavefunctions
 !
@@ -18,8 +19,13 @@ PROGRAM gdma
 !  along with this program; if not, write to
 !  the Free Software Foundation, Inc., 51 Franklin Street,
 !  Fifth Floor, Boston, MA 02110-1301, USA.
+!
+!  This version has been modified by Andy Simmonett (03/16) to link
+!  into Psi4, rather than serve as a standalone executable.
 
 USE input
+use iso_c_binding
+use iso_fortran_env, only : std_out=>output_unit
 USE version
 USE dma
 USE atom_grids, ONLY: debug_grid => debug
@@ -40,21 +46,74 @@ INTEGER :: ncoorb, maxl, cmax, nprim, nx, num, ich, mul
 INTEGER, ALLOCATABLE :: shell_type(:)
 INTEGER :: i, j, k, kp=0
 LOGICAL :: eof, fchk, first, ok=.false.
+INTEGER open_status, infile
 
 REAL(dp), ALLOCATABLE :: densty(:,:), dtri(:)
 INTEGER :: ir=5 ! Input stream
 
 LOGICAL :: verbose=.false., debug(0:2)=.false.
 
+CONTAINS
+
+
+subroutine run_gdma(c_outfilename, c_datfilename) bind(c, name='run_gdma')
+!character(kind=c_char,len=1), intent(in) :: c_outfilename
+CHARACTER(kind=C_CHAR) :: c_outfilename(*), c_datfilename(*)
+character(len=:), allocatable :: outfilename, datfilename
+integer i, nchars
+integer outfile
+
+i = 1
+do
+   if (c_outfilename(i) == c_null_char) exit
+   i = i + 1
+end do
+nchars = i - 1  ! Exclude null character from Fortran string
+!allocate(character(len=nchars) :: outfilename)
+outfilename = (repeat(' ', nchars))
+outfilename = transfer(c_outfilename(1:nchars), outfilename)
+i = 1
+do
+   if (c_datfilename(i) == c_null_char) exit
+   i = i + 1
+end do
+nchars = i - 1  ! Exclude null character from Fortran string
+!allocate(character(len=nchars) :: datfilename)
+datfilename = (repeat(' ', nchars))
+datfilename = transfer(c_datfilename(1:nchars), datfilename)
 
-print "(15x,a/15x,a//15x,a//15x,5a/14x,4a)",                           &
+!
+! Added file IO (ACS 03/16)
+!
+infile = 51
+outfile = 52
+open (unit=infile, file=datfilename, status='old', &
+    iostat=open_status, action='read', position='rewind')
+if ( open_status /= 0 ) then
+    write(outfile, *) 'Could not open GDMA input for reading.', &
+    'unit = ', infile
+    stop
+endif
+if(outfilename=='stdout') then
+  outfile=std_out
+else
+  open (unit=outfile, file=outfilename, status='old', &
+      iostat=open_status, action='write', position='append')
+  if ( open_status /= 0 ) then
+      write(outfile, *) 'Could not open psi4 output for writing.', &
+      'unit = ', infile
+      stop
+  endif
+endif
+!!!
+write(outfile, "(15x,a/15x,a//15x,a//15x,5a/14x,4a)")                  &
     "                      G D M A",                                   &
     "                  by Anthony Stone",                              &
     "Distributed Multipoles from Gaussian wavefunctions",              &
     "              version ", gdma_version, " (", commit, ")",         &
     "Compiled with ", compiler, " on ", compiled
 call time_and_date(datestring)
-print "(/2A)", "Starting at ", datestring
+write(outfile, "(/2A)") "Starting at ", datestring
 
 call start_timer
 
@@ -63,7 +122,7 @@ nat=0
 fchk=.false.
 first=.true.
 do
-  call read_line(eof)
+  call read_line(eof, infile)
   if (eof) exit
   call readu(key)
   select case(key)
@@ -99,7 +158,7 @@ do
     Qfactor=1d0
   case("COMMENT","TITLE")
     call reada(buffer)
-    print "(/a/)", trim(buffer)
+    write(outfile, "(/a/)") trim(buffer)
   case("DENSITY")
     if (fchk) call die                                         &
         ("Specify density to use before reading data file",.true.)
@@ -125,17 +184,17 @@ do
       end select
     end do
     ir=9
-    call get_data(whichd,ok)
+    call get_data(whichd,ok,outfile)
     close(9)
     ir=5
     fchk=.true.
   case ("HERE")
-    call get_data(whichd,ok)
+    call get_data(whichd,ok,outfile)
     fchk=.true.
   case("NAMES")
     if (.not. fchk) call die                                   &
         ("Read data file before specifying atom names",.false.)
-    call read_line(eof)
+    call read_line(eof, infile)
     do i=1,nat
       call geta(name(i))
     end do
@@ -156,9 +215,9 @@ do
       deallocate(densty)
       first=.false.
     endif
-    print "(//2A/)", "Using "//trim(whichd)//" density matrix",  &
+    write(outfile, "(//2A/)") "Using "//trim(whichd)//" density matrix",  &
         " from file "//trim(file)
-    call dma_main(dtri,kp)
+    call dma_main(dtri,kp,infile,outfile)
     call timer
   case("RESET")
     nat=0
@@ -175,17 +234,22 @@ do
 end do
 
 call time_and_date(datestring)
-print "(/2A)", "Finished at ", datestring
+write(outfile, "(/2A)") "Finished at ", datestring
+close(outfile)
+close(infile)
+end subroutine run_gdma
 
-CONTAINS
+
+!CONTAINS
 
 !-----------------------------------------------------------------------
 
-SUBROUTINE get_data(whichd,ok)
+SUBROUTINE get_data(whichd,ok,outfile)
 
 IMPLICIT NONE
 
 CHARACTER(LEN=*), INTENT(IN) :: whichd
+INTEGER, INTENT(IN) :: outfile
 LOGICAL, INTENT(OUT) :: ok
 
 INTEGER :: atom, i, j, k, n, nn, aok
@@ -220,6 +284,10 @@ CHARACTER(LEN=5) :: label(-5:5)=(/"h(s)","g(s)","f(s)","d(s)","sp  ",  &
 !  Conversion from normalised spherical form to normalised Cartesian
 !  Schlegel & Frisch, IJQC (1995) 54, 83-87.
 rt3v2=rt3/2d0
+!  d functions
+!   1   2   3   4   5   6
+!   xx  yy  zz  xy  xz  yz
+!  200 020 002 110 101 011
 td(1,:)=(/-0.5d0, -0.5d0, 1d0, 0d0, 0d0, 0d0/)
 td(2,:)=(/0d0,    0d0,    0d0, 0d0, 1d0, 0d0/)
 td(3,:)=(/0d0,    0d0,    0d0, 0d0, 0d0, 1d0/)
@@ -229,6 +297,7 @@ td(5,:)=(/0d0,    0d0,    0d0, 1d0, 0d0, 0d0/)
 !  f functions
 !   1   2   3   4   5   6   7   8   9   10
 !  xxx yyy zzz xxy xxz xyy yyz xzz yzz xyz
+!  300 030 003 210 201 120 021 102 012 111
 tf(:,:)=0d0
 ! 30
 tf(1,3)=1d0; tf(1,5)=-1.5d0/sqrt(5d0); tf(1,7)=-1.5d0/sqrt(5d0)
@@ -248,6 +317,8 @@ tf(7,2)=-sqrt(10d0)/4d0; tf(7,4)=0.75d0*sqrt(2d0)
 !  g functions
 !   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15
 ! xxxx yyyy zzzz xxxy xxxz xyyy yyyz xzzz yzzz xxyy xxzz yyzz xxyz xyyz xyzz
+!  400  040  004  310  301  130  031  103  013  220  202  022  211  121  112
+!     12   23  D     23 23,12  13  23,12 12  D      23  12
 tg=0d0
 !  40
 tg(1,v400)=0.375d0; tg(1,v040)=0.375d0; tg(1,v004)=1d0
@@ -329,8 +400,8 @@ call stream(ir)
 read (ir,"(A80/A80)") title(1), title(2)
 density_header="Total "//trim(whichd)//" Density"
 if (verbose) then
-  print "(a/a/a/)", "Gaussian header:", trim(title(1)), trim(title(2))
-  print "(3a)", 'Looking for "', trim(density_header), '"'
+  write(outfile, "(a/a/a/)") "Gaussian header:", trim(title(1)), trim(title(2))
+  write(outfile, "(3a)") 'Looking for "', trim(density_header), '"'
 end if
 do
   read (ir,"(A)",iostat=k) buffer
@@ -338,7 +409,7 @@ do
     call stream(5)
     exit
   end if
-  if (debug(0)) print "(a)", buffer
+  if (debug(0)) write(outfile, "(a)") buffer
   text=buffer(1:40)
   type=buffer(44:44)
   ww=buffer(48:49)
@@ -347,7 +418,7 @@ do
   else
     nn=0
   endif
-  if (debug(0)) print "(a)", text
+  if (debug(0)) write(outfile, "(a)") text
   select case(text)
   case("")
     cycle
@@ -356,7 +427,7 @@ do
     exit
   case("Number of atoms")
     read(buffer,"(55X,I6)") nat
-    if (verbose) print "(i0,a)", nat, " atoms"
+    if (verbose) write(outfile, "(i0,a)") nat, " atoms"
     if (allocated(zan)) deallocate(zan,c)
     allocate(zan(nat),c(3,nat),stat=aok)
     if (aok>0) call die("Can't allocate atom arrays")
@@ -367,18 +438,18 @@ do
     if (aok>0) call die("Can't allocate site-name array")
   case("Charge")
     read(buffer,"(55X,I6)") ich
-    if (verbose) print "(a,i0)", "Charge ", ich
+    if (verbose) write(outfile, "(a,i0)") "Charge ", ich
   case("Multiplicity")
     read(buffer,"(55X,I6)") mul
-    if (verbose) print "(a,i0)", "Multiplicity ", mul
+    if (verbose) write(outfile, "(a,i0)") "Multiplicity ", mul
   case("Number of basis functions")
     read(buffer,"(55X,I6)") ncoorb
     !  This number may be increased following conversion from
     !  spherical to cartesian
-    if (verbose) print "(i0,a)", ncoorb, " basis functions"
+    if (verbose) write(outfile, "(i0,a)") ncoorb, " basis functions"
   case("Number of contracted shells")
     read(buffer,"(55X,I6)") nshell
-    if (verbose) print "(i0,a)", nshell, " shells"
+    if (verbose) write(outfile, "(i0,a)") nshell, " shells"
     if (allocated(kstart))                                             &
         deallocate(kstart,katom,ktype,kng,kloc,kmin,kmax,shell_type)
     allocate (kstart(nshell), katom(nshell+1), ktype(nshell),          &
@@ -388,17 +459,17 @@ do
     shell_type=0
   case("Highest angular momentum")
     read(buffer,"(55X,I6)") maxl
-    if (verbose) print "(a,i0)", "Highest angular momentum ", maxl
+    if (verbose) write(outfile, "(a,i0)") "Highest angular momentum ", maxl
     if (maxl > 5) call die                                 &
         ("Sorry -- GDMA can only handle s, p, d, f, g and h basis functions",.false.)
   case("Largest degree of contraction")
     read(buffer,"(55X,I6)") cmax
-    if (verbose) print "(a,i0)", "Largest contraction depth ", cmax
+    if (verbose) write(outfile, "(a,i0)") "Largest contraction depth ", cmax
     ! if (cmax .gt. 16) call die                                &
     !     ("Sorry -- maximum contraction depth is 16",.false.)
   case("Number of primitive shells")
     read(buffer,"(55X,I6)") nprim
-    if (verbose) print "(i0,a)", nprim, " primitive shells"
+    if (verbose) write(outfile, "(i0,a)") nprim, " primitive shells"
     if (allocated(ex)) deallocate(ex,cs,cp)
     allocate(ex(nprim), cs(nprim), cp(nprim), stat=aok)
     if (aok>0) then
@@ -411,23 +482,23 @@ do
       call geti(k)
       name(i)=element(k)
     end do
-    if (verbose) print "(a,20a3/(17x,20a3))",                    &
+    if (verbose) write(outfile, "(a,20a3/(17x,20a3))")                    &
         "Atoms:            ", name(1:nat)
   case("Nuclear charges")
     call read_line(eof)
     do i=1,nat
       call getf(zan(i))
     end do
-    if (verbose) print "(a,20i3/(16x,20i3))",                    &
+    if (verbose) write(outfile, "(a,20i3/(16x,20i3))")                    &
         "Nuclear charges:", nint(zan(1:nat))
   case("Current cartesian coordinates")
     call read_line(eof)
-    if (verbose) print "(a)", "Atom  Z   Position (a.u.)"
+    if (verbose) write(outfile, "(a)") "Atom  Z   Position (a.u.)"
     do i=1,nat
       do j=1,3
         call getf(c(j,i),rfact)
       end do
-      if (verbose) print "(a3,i4,3f10.5)", name(i), nint(zan(i)), c(:,i)
+      if (verbose) write(outfile, "(a3,i4,3f10.5)") name(i), nint(zan(i)), c(:,i)
     end do
   case("Shell types")
     call read_line(eof)
@@ -467,9 +538,9 @@ do
         num=num+13; n=n+28
       end select
     end do
-    if (verbose) print "(i0,a)", num, " basis functions"
+    if (verbose) write(outfile, "(i0,a)") num, " basis functions"
     if ((verbose) .and. n>num)                           &
-        print "(a,i0,a)", "(", n, " after conversion to cartesian)"
+        write(outfile, "(a,i0,a)") "(", n, " after conversion to cartesian)"
     maxbfn = n
     if (allocated(iax)) deallocate(iax)
     allocate(iax(n+1), stat=aok)
@@ -486,8 +557,8 @@ do
       kng(i)=j
     end do
     if (verbose) then
-      print "(a,20i3/(19x,20i3))", "Contraction depths:", kng(1:nshell)
-      print "(a,i0)", "Total number of primitives required: ", k-1
+      write(outfile, "(a,20i3/(19x,20i3))") "Contraction depths:", kng(1:nshell)
+      write(outfile, "(a,i0)") "Total number of primitives required: ", k-1
     end if
     if (k .ne. nprim+1) call die                              &
         ("Shell contractions do not match number of primitives",.false.)
@@ -496,6 +567,9 @@ do
     do i=1,nshell
       call geti(katom(i))
     end do
+    if (verbose) then
+      write(outfile, "(a,120i3)") "shell to atom", katom(1:nshell)
+    endif
   case("Primitive exponents")
     call read_line(eof)
     do i=1,nprim
@@ -534,7 +608,7 @@ do
     end do
 !   case("Alpha MO coefficients","Beta MO coefficients")
 !     if (debug(2)) then
-!       print "(/a)", text
+!       write(outfile, "(/a)") text
 !       allocate(temp(ncoorb,ncoorb))
 !       do i=1,ncoorb
 !         do j=1,ncoorb
@@ -578,19 +652,19 @@ if (verbose) then
   do i=1,nshell
     if (katom(i) .ne. atom) then
       atom=katom(i)
-      print "(a)", name(atom)
+      write(outfile, "(a)") name(atom)
     end if
-    print "(a,i0,3x,a)", "Shell ", i, label(shell_type(i))
+    write(outfile, "(a,i0,3x,a)") "Shell ", i, label(shell_type(i))
     do j=kstart(i),kstart(i)+kng(i)-1
       select case (shell_type(i))
       case (-1)
-        print "(i10,f16.8, 2f14.8)", j, ex(j), cs(j), cp(j)
+        write(outfile, "(i10,f16.8, 2f14.8)") j, ex(j), cs(j), cp(j)
       case(0)
-        print "(i10,f16.8, 2f14.8)", j, ex(j), cs(j)
+        write(outfile, "(i10,f16.8, 2f14.8)") j, ex(j), cs(j)
       case(1)
-        print "(i10,f16.8, 2f14.8)", j, ex(j), cp(j)
+        write(outfile, "(i10,f16.8, 2f14.8)") j, ex(j), cp(j)
       case default
-        print "(i10,f16.8, 2f14.8)", j, ex(j), cs(j)
+        write(outfile, "(i10,f16.8, 2f14.8)") j, ex(j), cs(j)
       end select
     end do
   end do
@@ -672,7 +746,7 @@ do i=1,nshell
     kmin(i)=21
     kmax(i)=35
     ktype(i)=5
-    ! print "(a,i0,a,i0)", "num = ", num, "  k = ", k
+    ! write(outfile, "(a,i0,a,i0)") "num = ", num, "  k = ", k
     if (shell_type(i) .lt. 0) then ! Spherical g shell
       temp(1:num,1:k)=densty(1:num,1:k)
       temp(1:num,k+1:k+15)=matmul(densty(1:num,k+1:k+9),tg)
@@ -686,7 +760,7 @@ do i=1,nshell
     kmin(i)=36
     kmax(i)=56
     ktype(i)=6
-    ! print "(a,i0,a,i0)", "num = ", num, "  k = ", k
+    ! write(outfile, "(a,i0,a,i0)") "num = ", num, "  k = ", k
     if (shell_type(i) .lt. 0) then ! Spherical h shell
       temp(1:num,1:k)=densty(1:num,1:k)
       temp(1:num,k+1:k+21)=matmul(densty(1:num,k+1:k+11),th)
@@ -747,4 +821,5 @@ end do
 
 END SUBROUTINE matwrtt
 
-END PROGRAM gdma
+END module libgdma
+
diff --git a/src/input.F90 b/src/input.F90
index 10e60b4..a999cbb 100644
--- a/src/input.F90
+++ b/src/input.F90
@@ -628,7 +628,11 @@ else
   m=char(l:end(item))
   length=end(item)-l+1
 endif
-if (len(m) .lt. length) print "(A)", "WARNING: string truncated"
+!if (len(m) .lt. length) print "(A)", "WARNING: string truncated"
+! LAB Jun 2018 -- it reads longish (40 char) files twice, apparently
+!   correctly, but doesn't set `m` right, so the lengths don't align,
+!   so it reads it again, this time in full. I can't understand it,
+!   and appears harmless so I'm silencing the warning.
 
 END SUBROUTINE reada
 
-- 
2.40.1

